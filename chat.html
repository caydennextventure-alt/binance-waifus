<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.jsdelivr.net https:; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self' data: blob:; font-src 'self' data: https://fonts.gstatic.com; connect-src 'self' blob: data: http://localhost:* ws://localhost:* https://api.elevenlabs.io https://api.openai.com https://*.supabase.co wss://*.supabase.co https://infragrid.v.network https://*.v.network https://vrm-eliza-ai-girlfriend.vercel.app https://*.railway.app https://vrm-elizaos-ai-girlfriend-production.up.railway.app https://api.xwaifus.com; media-src 'self' blob: data:; object-src 'none'; base-uri 'self'; form-action 'self';">
    <title data-i18n-title="app.title">AI Girlfriend Chat Game ðŸŒ¸</title>
    <link rel="icon" type="image/png" href="assets/wallet/favicon-circle.png">
    <link rel="stylesheet" href="chat-ui.css?v=anime_polish_v2">
    <!-- Removed dead link: wallet-ui.css -->
    <link rel="stylesheet" href="chat-responsive.css">
    <!-- Local fonts now used via chat-ui.css @font-face -->

    <!-- Configuration files -->
    <script src="config.js"></script>
    <!-- Auto-generated character i18n (must load before i18n.js) -->
    <script src="i18n.characters.generated.js"></script>
    <!-- Internationalization support -->
    <script src="i18n.js"></script>
    <!-- Memory system handled by ElizaOS backend -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: transparent;
            height: 100vh;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* VRM display area - full screen */
        .vrm-container {
            width: 100%;
            height: 100%;
            position: relative;
            /* Remove CSS background to show Three.js scene background */
            background: transparent;
        }

        /* ðŸŽ¤ Voice play button */
        .voice-play-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            cursor: pointer;
            margin-top: 5px;
            margin-left: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .voice-play-btn:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .voice-play-btn:active {
            transform: translateY(0);
        }

        /* AI dialogue bubble */
        .ai-speech-bubble {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(220, 220, 220, 0.95);
            color: #333;
            padding: 18px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 500;
            max-width: 450px;
            min-width: 250px;
            text-align: center;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
            opacity: 0;
            animation: bubbleFadeIn 0.5s forwards;
            z-index: 1100;
            line-height: 1.5;
            letter-spacing: 0.5px;
        }

        .ai-speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 18px solid transparent;
            border-right: 18px solid transparent;
            border-top: 18px solid rgba(220, 220, 220, 0.95);
        }

        @keyframes bubbleFadeIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes bubbleFadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }

        .vrm-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }



        /* Retro music player */
        .music-controls {
            position: absolute;
            top: 25px;
            left: 25px;
            width: 280px;
            height: 120px;
            background: linear-gradient(135deg, #e8b4ff 0%, #d19cff 50%, #b96fff 100%);
            border-radius: 15px;
            border: 6px solid #4a2c5a;
            color: #2d1b3d;
            z-index: 1001;
            padding: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3), inset 0 2px 0 rgba(255, 255, 255, 0.4);
            font-family: 'Arial', sans-serif;
        }

        .music-window-title {
            background: linear-gradient(90deg, #ffb366 0%, #ffa64d 100%);
            margin: -15px -15px 10px -15px;
            padding: 8px 15px;
            border-radius: 9px 9px 0 0;
            font-size: 12px;
            font-weight: bold;
            color: #2d1b3d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .window-controls {
            display: flex;
            gap: 5px;
        }

        .window-btn {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
        }

        .minimize-btn {
            background: #ffd23f;
        }

        .maximize-btn {
            background: #28ca42;
        }

        .close-btn {
            background: #ff5f57;
        }

        .music-player-content {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .music-controls-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .music-control-btn {
            width: 35px;
            height: 25px;
            background: #6c4a7a;
            border: 2px solid #2d1b3d;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .music-control-btn:hover {
            background: #8b5fa3;
            transform: translateY(-1px);
        }

        .play-btn {
            width: 45px !important;
            background: #4a7c59 !important;
        }

        .play-btn:hover {
            background: #5d9973 !important;
        }

        .volume-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .volume-slider {
            width: 120px;
            height: 4px;
            border-radius: 2px;
            background: #4a2c5a;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 2px;
            background: #ffb366;
            cursor: pointer;
            border: 1px solid #2d1b3d;
        }

        .volume-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            background: #ffb366;
            cursor: pointer;
            border: 1px solid #2d1b3d;
        }

        .volume-label {
            font-size: 10px;
            min-width: 25px;
            font-weight: bold;
            text-align: right;
        }

        /* Language switcher */
        .language-toggle {
            position: absolute;
            bottom: 25px;
            left: 25px;
            background: linear-gradient(135deg, #ff9a56 0%, #ffad56 50%, #ffc056 100%);
            border-radius: 10px;
            border: 4px solid #4a2c5a;
            padding: 8px 15px;
            z-index: 1002;
            scale: 0.6;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #2d1b3d;
            font-weight: bold;
            font-size: 12px;
        }

        .language-btn {
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid #4a2c5a;
            border-radius: 6px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
            color: #2d1b3d;
            transition: all 0.2s ease;
        }

        .language-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.05);
        }

        .language-btn.active {
            background: #4a2c5a;
            color: white;
        }


        .emotion-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-bottom: 10px;
        }

        .emotion-btn {
            padding: 8px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .emotion-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .emotion-btn.active {
            background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%);
            color: #2d3436;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .vrm-container {
                width: 100%;
                height: 100vh;
            }
        }

        /* Animation effects */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Back button */
        .back-button {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
            z-index: 1000;
        }

        .back-button:hover {
            background: rgba(255, 107, 157, 0.8);
            transform: translateY(-2px);
        }

        /* Wallet status display */
        .wallet-status-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 20px;
            color: white;
            font-size: 12px;
            scale: 0.6;
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .wallet-avatar svg {
            color: #8b5cf6;
        }

        .wallet-address {
            font-family: 'Courier New', monospace;
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 5px;
        }

        .wallet-disconnect {
            background: rgba(255, 69, 58, 0.8);
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .wallet-disconnect:hover {
            background: rgba(255, 69, 58, 1);
        }

        /* Connect wallet button */
        .connect-wallet-btn {
            background: linear-gradient(135deg, #9945ff, #14f195);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .connect-wallet-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(153, 69, 255, 0.4);
        }

        /* Unauthorized interface */
        .unauthorized-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }

        .unauthorized-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            color: #333;
        }

        .unauthorized-content h2 {
            margin-bottom: 20px;
            color: #ff6b9d;
        }

        .unauthorized-content p {
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .connect-wallet-btn {
            background: linear-gradient(135deg, #9945ff, #14f195);
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .connect-wallet-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(153, 69, 255, 0.4);
        }

        /* Floating chat box */
        .floating-chat {
            position: fixed;
            /* Avoid translateY-based centering to prevent vertical jitter when hovering */
            top: 120px;
            right: 20px;
            transform: none;
            width: 416px;
            height: 754px;
            background: #F5F3F0;
            border-radius: 33px;
            border: 10px solid #2C1810;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4),
                0 0 30px rgba(44, 24, 16, 0.2),
                inset 0 2px 0 rgba(255, 255, 255, 0.3);
            z-index: 1000;
            cursor: move;
            user-select: none;
            overflow: hidden;
        }


        .floating-chat.dragging {
            transform: scale(1.05);
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.5),
                0 0 40px rgba(255, 182, 193, 0.8),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            cursor: grabbing;
        }

        /* Mobile top bar style chat header */
        .chat-window-header {
            border-radius: 23px 23px 0 0;
            padding: 0;
            border-bottom: none;
            display: flex;
            flex-direction: column;
            cursor: grab;
            user-select: none;
            position: relative;
            overflow: hidden;
            width: 100%;
        }

        .chat-window-header:active {
            cursor: grabbing;
        }

        /* Real mobile status bar */
        .phone-status-bar {
            background: #000000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 16px;
            font-size: 14px;
            color: white;
            font-weight: 600;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            height: 24px;
            border-radius: 23px 23px 0 0;
            width: 100%;
            box-sizing: border-box;
        }

        .status-left {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
        }

        .carrier-info {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 14px;
            font-weight: 600;
        }

        .network-type {
            font-size: 14px;
            font-weight: 600;
        }

        .status-center {
            flex: 1;
            display: flex;
            justify-content: center;
        }

        .time-display {
            font-weight: 700;
            font-size: 14px;
            letter-spacing: -0.2px;
        }

        .status-right {
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1;
            justify-content: flex-end;
        }

        .status-icon {
            display: flex;
            align-items: center;
        }

        .battery-percentage {
            font-size: 14px;
            font-weight: 600;
            margin-right: 2px;
        }

        /* Anime-style chat title area */
        .chat-title-area {
            position: relative;
            padding: 16px 20px;
            background: linear-gradient(135deg,
                    #FF6B9D 0%,
                    #C44569 25%,
                    #7B68EE 50%,
                    #9B59B6 75%,
                    #E056FD 100%);
            border-bottom: none;
            overflow: hidden;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        /* Anime-style background decoration */
        .chat-title-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                radial-gradient(circle at 20% 80%, rgba(255, 255, 255, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(255, 182, 193, 0.1) 0%, transparent 50%);
            pointer-events: none;
        }

        /* Anime-style star decoration */
        .chat-title-area::after {
            content: 'âœ¨ðŸŒ¸âœ¨';
            position: absolute;
            top: 8px;
            right: 20px;
            font-size: 12px;
            opacity: 0.7;
            animation: sparkle 3s ease-in-out infinite;
        }

        @keyframes sparkle {

            0%,
            100% {
                opacity: 0.7;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.1);
            }
        }

        .chat-user-info {
            display: flex;
            align-items: center;
            gap: 14px;
            position: relative;
            z-index: 2;
        }

        /* Cute avatar design - using same avatar as chat bubble */
        .chat-user-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: url('profile-pic/alice-pf.png') center/cover;
            border: 3px solid rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            position: relative;
            box-shadow:
                0 4px 15px rgba(255, 182, 193, 0.4),
                0 2px 8px rgba(0, 0, 0, 0.1),
                inset 0 2px 0 rgba(255, 255, 255, 0.6);
            animation: avatarFloat 4s ease-in-out infinite;
        }

        /* Different character avatars for title bar */
        .character-fliza .chat-user-avatar {
            background-image: url('profile-pic/fliza-pf.png');
        }

        .character-alice .chat-user-avatar {
            background-image: url('profile-pic/alice-pf.png');
        }

        .character-ash .chat-user-avatar {
            background-image: url('profile-pic/ash-pf.png');
        }

        .character-bobo .chat-user-avatar {
            background-image: url('profile-pic/bobo-pf.png');
        }

        .character-elinyaa .chat-user-avatar {
            background-image: url('profile-pic/elinyaa-pf.png');
        }

        .character-imeris .chat-user-avatar {
            background-image: url('profile-pic/imeris-pf.png');
        }

        .character-kyoko .chat-user-avatar {
            background-image: url('profile-pic/kyoko-pf.png');
        }

        .character-lena .chat-user-avatar {
            background-image: url('profile-pic/lena-pf.png');
        }

        .character-lilium .chat-user-avatar {
            background-image: url('profile-pic/lilium.png');
        }

        .character-maple .chat-user-avatar {
            background-image: url('profile-pic/maple-pf.png');
        }

        .character-miru .chat-user-avatar {
            background-image: url('profile-pic/Miru-pf.png');
        }

        .character-miumiu .chat-user-avatar {
            background-image: url('profile-pic/miumiu-pf.png');
        }

        .character-neco .chat-user-avatar {
            background-image: url('profile-pic/neco-pf.png');
        }

        .character-nekona .chat-user-avatar {
            background-image: url('profile-pic/nekona.png');
        }

        .character-notia .chat-user-avatar {
            background-image: url('profile-pic/notia-pf.png');
        }

        .character-ququ .chat-user-avatar {
            background-image: url('profile-pic/ququ-pf.png');
        }

        .character-rainy .chat-user-avatar {
            background-image: url('profile-pic/rainy-pf.png');
        }

        .character-rindo .chat-user-avatar {
            background-image: url('profile-pic/rindo-pf.png');
        }

        .character-sikirei .chat-user-avatar {
            background-image: url('profile-pic/sikirei-pf.png');
        }

        .character-vivi .chat-user-avatar {
            background-image: url('profile-pic/vivi-pf.png');
        }

        .character-wolf .chat-user-avatar {
            background-image: url('profile-pic/wolf.png');
        }

        .character-wolferia .chat-user-avatar {
            background-image: url('profile-pic/wolferia-pf.png');
        }

        .character-yawl .chat-user-avatar {
            background-image: url('profile-pic/yawl-pf.png');
        }

        .character-yuu .chat-user-avatar {
            background-image: url('profile-pic/yuu yii-pf.png');
        }

        .character-zwei .chat-user-avatar {
            background-image: url('profile-pic/zwei-pf.png');
        }

        @keyframes avatarFloat {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-2px);
            }
        }

        /* Avatar glow effect */
        .chat-user-avatar::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-radius: 50%;
            background: linear-gradient(45deg,
                    transparent,
                    rgba(255, 255, 255, 0.3),
                    transparent);
            animation: haloRotate 6s linear infinite;
        }

        @keyframes haloRotate {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .chat-user-details {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .chat-user-name {
            color: white;
            font-size: 18px;
            font-weight: 700;
            margin: 0;
            text-shadow:
                0 2px 4px rgba(0, 0, 0, 0.3),
                0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
        }

        /* Small decoration before character name */
        .chat-user-name::before {
            content: 'ðŸ’•';
            margin-right: 6px;
            font-size: 14px;
            animation: heartBeat 2s ease-in-out infinite;
        }

        @keyframes heartBeat {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        .chat-user-status {
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px;
            margin: 0;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            position: relative;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Status indicator */
        .chat-user-status::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4AE54A;
            box-shadow:
                0 0 0 2px rgba(74, 229, 74, 0.3),
                0 0 8px rgba(74, 229, 74, 0.6);
            animation: onlinePulse 2s ease-in-out infinite;
        }

        @keyframes onlinePulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }
        }

        /* Cute action buttons */
        .chat-actions {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 2;
        }

        .chat-action-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.25) 0%,
                    rgba(255, 255, 255, 0.1) 100%);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        /* Button light effects */
        .chat-action-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(255, 255, 255, 0.4),
                    transparent);
            transition: left 0.6s;
        }

        .chat-action-btn:hover {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.35) 0%,
                    rgba(255, 255, 255, 0.2) 100%);
            transform: translateY(-2px) scale(1.05);
            box-shadow:
                0 8px 25px rgba(255, 182, 193, 0.4),
                0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .chat-action-btn:hover::before {
            left: 100%;
        }

        .chat-action-btn:active {
            transform: translateY(0) scale(0.98);
        }

        /* Special effects: button decorations */
        .chat-action-btn:nth-child(1) {
            animation-delay: 0.1s;
        }

        .chat-action-btn:nth-child(2) {
            animation-delay: 0.2s;
        }

        .chat-action-btn:nth-child(3) {
            animation-delay: 0.3s;
        }

        /* Chat message area */
        .chat-window-messages {
            height: 585px;
            padding: 26px 20px;
            overflow-y: auto;
            background: #F5F3F0;
        }

        .chat-window-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-window-messages::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .chat-window-messages::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        /* Old .message-bubble styles removed - using ElizaOS .message structure instead */

        /* ElizaOS Message Structure Bubble Styling */
        .message {
            margin-bottom: 18px;
            animation: messageSlideIn 0.4s ease-out;
            display: flex;
        }

        .message.user-message {
            justify-content: flex-end;
        }

        .message.ai-message {
            justify-content: flex-start;
            position: relative;
            padding-left: 54px;
        }

        /* Character avatars for ElizaOS messages */
        .message.ai-message::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            border: 2px solid #FFD700;
            box-shadow: 0 2px 8px rgba(255, 215, 0, 0.3);
        }

        .character-fliza .message.ai-message::before {
            background-image: url('profile-pic/fliza-pf.png');
        }

        .character-alice .message.ai-message::before {
            background-image: url('profile-pic/alice-pf.png');
        }

        .character-ash .message.ai-message::before {
            background-image: url('profile-pic/ash-pf.png');
        }

        .character-bobo .message.ai-message::before {
            background-image: url('profile-pic/bobo-pf.png');
        }

        .character-elinyaa .message.ai-message::before {
            background-image: url('profile-pic/elinyaa-pf.png');
        }

        .character-imeris .message.ai-message::before {
            background-image: url('profile-pic/imeris-pf.png');
        }

        .character-kyoko .message.ai-message::before {
            background-image: url('profile-pic/kyoko-pf.png');
        }

        .character-lena .message.ai-message::before {
            background-image: url('profile-pic/lena-pf.png');
        }

        .character-lilium .message.ai-message::before {
            background-image: url('profile-pic/lilium.png');
        }

        .character-maple .message.ai-message::before {
            background-image: url('profile-pic/maple-pf.png');
        }

        .character-miru .message.ai-message::before {
            background-image: url('profile-pic/Miru-pf.png');
        }

        .character-miumiu .message.ai-message::before {
            background-image: url('profile-pic/miumiu-pf.png');
        }

        .character-neco .message.ai-message::before {
            background-image: url('profile-pic/neco-pf.png');
        }

        .character-nekona .message.ai-message::before {
            background-image: url('profile-pic/nekona.png');
        }

        .character-notia .message.ai-message::before {
            background-image: url('profile-pic/notia-pf.png');
        }

        .character-ququ .message.ai-message::before {
            background-image: url('profile-pic/ququ-pf.png');
        }

        .character-rainy .message.ai-message::before {
            background-image: url('profile-pic/rainy-pf.png');
        }

        .character-rindo .message.ai-message::before {
            background-image: url('profile-pic/rindo-pf.png');
        }

        .character-sikirei .message.ai-message::before {
            background-image: url('profile-pic/sikirei-pf.png');
        }

        .character-vivi .message.ai-message::before {
            background-image: url('profile-pic/vivi-pf.png');
        }

        .character-wolf .message.ai-message::before {
            background-image: url('profile-pic/wolf.png');
        }

        .character-wolferia .message.ai-message::before {
            background-image: url('profile-pic/wolferia-pf.png');
        }

        .character-yawl .message.ai-message::before {
            background-image: url('profile-pic/yawl-pf.png');
        }

        .character-yuu .message.ai-message::before {
            background-image: url('profile-pic/yuu yii-pf.png');
        }

        .character-zwei .message.ai-message::before {
            background-image: url('profile-pic/zwei-pf.png');
        }

        .message-content {
            max-width: 80%;
            position: relative;
        }

        .message.ai-message .message-text {
            background: linear-gradient(135deg, #FFB084 0%, #FF9D6B 50%, #FF8A50 100%) !important;
            border-radius: 20px 20px 20px 5px !important;
            padding: 16px 20px !important;
            color: white !important;
            font-size: 18px !important;
            line-height: 1.5 !important;
            position: relative !important;
            max-width: 300px !important;
            word-wrap: break-word !important;
            margin: 0 !important;
            box-shadow: 0 4px 12px rgba(255, 157, 107, 0.3),
                0 2px 6px rgba(139, 69, 19, 0.2) !important;
            border: none !important;
            text-shadow: 0 1px 2px rgba(139, 69, 19, 0.3) !important;
            display: block !important;
        }

        .message.ai-message .message-text::after {
            content: '';
            position: absolute;
            bottom: 0px;
            left: -8px;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 12px 12px 0;
            border-color: transparent #FF8A50 transparent transparent;
        }

        .message.ai-message .message-time {
            background: none !important;
            border-radius: none !important;
            padding: 0 !important;
            font-size: 12px !important;
            color: rgba(0, 0, 0, 0.7) !important;
            font-weight: bold !important;
            display: block !important;
            margin-bottom: 0 !important;
        }

        .message.user-message .message-text {
            background: linear-gradient(135deg, #F0F0F0 0%, #E0E0E0 50%, #D0D0D0 100%) !important;
            color: #333 !important;
            border-radius: 20px 20px 5px 20px !important;
            padding: 16px 20px !important;
            font-size: 18px !important;
            box-shadow: 0 4px 12px rgba(224, 224, 224, 0.4),
                0 2px 6px rgba(0, 0, 0, 0.1) !important;
        }

        .message.user-message .message-time {
            background: transparent !important;
            color: #333 !important;
            border-radius: none !important;
            padding: 0 !important;
            font-size: 12px !important;
            font-weight: normal !important;
        }


        #chat-window-messages .message-bubble.ai .bubble-header,
        .chat-window-messages .message-bubble.ai .bubble-header,
        .message-bubble.ai .bubble-header,
        .bubble-header {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(255, 182, 193, 0.9)) !important;
            border-radius: 15px 15px 0 0 !important;
            padding: 6px 12px !important;
            font-size: 12px !important;
            color: rgba(0, 0, 0, 0.7) !important;
            font-weight: bold !important;
            display: flex !important;
            align-items: center !important;
            justify-content: space-between !important;
        }

        #chat-window-messages .message-bubble.ai .bubble-content,
        .chat-window-messages .message-bubble.ai .bubble-content,
        .message-bubble.ai .bubble-content {
            background: linear-gradient(135deg, #FFB084 0%, #FF9D6B 50%, #FF8A50 100%) !important;
            border-radius: 20px 20px 20px 5px !important;
            padding: 16px 20px !important;
            color: white !important;
            font-size: 18px !important;
            line-height: 1.5 !important;
            position: relative !important;
            max-width: 300px !important;
            word-wrap: break-word !important;
            margin: 8px 0 !important;
            box-shadow: 0 4px 12px rgba(255, 157, 107, 0.3),
                0 2px 6px rgba(139, 69, 19, 0.2) !important;
            border: none !important;
            text-shadow: 0 1px 2px rgba(139, 69, 19, 0.3) !important;
            display: block !important;
        }

        .chat-window-messages .bubble-content,
        .bubble-content {
            background: linear-gradient(135deg, #FFB084 0%, #FF9D6B 50%, #FF8A50 100%) !important;
            border-radius: 20px 20px 20px 5px !important;
            padding: 16px 20px !important;
            color: white !important;
            font-size: 18px !important;
            line-height: 1.5 !important;
            position: relative !important;
            max-width: 300px !important;
            word-wrap: break-word !important;
            margin: 8px 0 !important;
            box-shadow: 0 4px 12px rgba(255, 157, 107, 0.3),
                0 2px 6px rgba(139, 69, 19, 0.2) !important;
            border: none !important;
            text-shadow: 0 1px 2px rgba(139, 69, 19, 0.3) !important;
        }

        .message-bubble.ai .bubble-content::after {
            content: '';
            position: absolute;
            bottom: 0px;
            left: -8px;
            width: 0;
            height: 0;
            border-right: 12px solid #FF9D6B;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            filter: drop-shadow(-2px 2px 4px rgba(139, 69, 19, 0.15));
        }

        .message-bubble.user .bubble-header {
            background: #E0E0E0;
            color: #333;
        }

        .message-bubble.user .bubble-content {
            background: linear-gradient(135deg, #F0F0F0 0%, #E0E0E0 50%, #D0D0D0 100%);
            color: #333;
            border-radius: 20px 20px 5px 20px;
            box-shadow: 0 4px 12px rgba(224, 224, 224, 0.4),
                0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .message-bubble.user .bubble-content::after {
            content: '';
            position: absolute;
            bottom: 0px;
            right: -8px;
            width: 0;
            height: 0;
            border-left: 12px solid #E0E0E0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.1));
        }


        .bubble-controls {
            display: flex;
            gap: 4px;
        }

        .bubble-control {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            background: rgba(0, 0, 0, 0.3);
        }

        /* Chat input area - minimalist style */
        .chat-window-input {
            padding: 12px 16px 16px;
            background: linear-gradient(180deg, #FAFAFA 0%, #F5F5F5 100%);
            border-radius: 0 0 23px 23px;
            border-top: 1px solid rgba(0, 0, 0, 0.08);
            cursor: auto;
        }

        .chat-window-messages {
            cursor: auto;
        }

        .input-container {
            display: flex;
            background: white;
            border-radius: 24px;
            border: 1px solid rgba(0, 0, 0, 0.08);
            overflow: hidden;
            align-items: center;
            padding: 4px 4px 4px 16px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }

        .input-container:focus-within {
            border-color: rgba(255, 182, 193, 0.5);
            box-shadow: 0 0 0 3px rgba(255, 182, 193, 0.1),
                0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .chat-input-field {
            flex: 1;
            padding: 10px 0;
            border: none;
            background: transparent;
            font-size: 16px;
            outline: none;
            color: #333;
            line-height: 1.5;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', sans-serif;
        }

        .chat-input-field::placeholder {
            color: rgba(0, 0, 0, 0.35);
            font-size: 15px;
        }

        .chat-input-field:focus {
            background: transparent;
        }

        /* Send button - minimal paper plane style */
        .send-btn {
            background: linear-gradient(135deg, #667EEA 0%, #764BA2 100%);
            border: none;
            padding: 0;
            color: white;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 20px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .send-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            transition: transform 0.3s ease;
        }

        .send-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .send-btn:hover::before {
            transform: translate(-50%, -50%) scale(1.2);
        }

        .send-btn:active {
            transform: translateY(0) scale(0.96);
        }

        /* Send animation effects */
        .send-btn.sending {
            animation: paperPlane 0.6s ease-out;
        }

        @keyframes paperPlane {
            0% {
                transform: translateY(-1px) scale(1);
            }

            50% {
                transform: translateY(-3px) scale(1.1) rotate(10deg);
            }

            100% {
                transform: translateY(-1px) scale(1) rotate(0deg);
            }
        }

        .send-btn.sending svg {
            animation: planeFly 0.6s ease-out;
        }

        @keyframes planeFly {
            0% {
                transform: translateX(0) rotate(0deg);
            }

            50% {
                transform: translateX(2px) rotate(15deg);
            }

            100% {
                transform: translateX(0) rotate(0deg);
            }
        }

        /* Additional function button area (optional) */
        .input-extras {
            display: flex;
            gap: 8px;
            margin-right: 8px;
            align-items: center;
        }

        .input-extra-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: transparent;
            border: none;
            color: rgba(0, 0, 0, 0.4);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: 16px;
        }

        .input-extra-btn:hover {
            background: rgba(0, 0, 0, 0.05);
            color: rgba(0, 0, 0, 0.7);
        }

        /* Animation effects */
        @keyframes messageSlideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .floating-chat {
                width: 800px;
                height: 700px;
                right: -170px;
                scale: 0.5;
                top: -152px;
            }

            .chat-window-messages {
                height: 495px;
            }
        }

        @media (max-width: 768px) {
            .floating-chat {
                bottom: 30px;
                left: -105px;
                right: 0px;
                width: 160vw;
                height: 365dvh;
                border-radius: -10px;
                border-width: -15px;
                transform: none;
            }

            .chat-window-header {
                cursor: default;
            }

            .chat-window-messages {
                height: calc(100dvh - 140px);
                /* header + input approx */
            }

            .music-controls {
                display: none;
            }
        }

        /* Mobile Portrait Layout - UI Optimization */
        @media (max-width: 768px) and (orientation: portrait) {

            /* Floating Chat - Transparent glass effect for portrait */
            .floating-chat {
                background: rgba(255, 255, 255, 0.1) !important;
                backdrop-filter: blur(20px) saturate(180%) !important;
                -webkit-backdrop-filter: blur(20px) saturate(180%) !important;
                border: 1px solid rgba(255, 255, 255, 0.2) !important;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1) !important;
            }

            /* Chat Messages Area - Transparent glass effect */
            .chat-window-messages {
                background: rgba(255, 255, 255, 0.05) !important;
                backdrop-filter: blur(15px) saturate(160%) !important;
                -webkit-backdrop-filter: blur(15px) saturate(160%) !important;
                border: 1px solid rgba(255, 255, 255, 0.1) !important;
                border-radius: 12px !important;
            }

            /* Chat Input Area - Transparent glass effect */
            .chat-window-input {
                background: rgba(255, 255, 255, 0.05) !important;
                backdrop-filter: blur(15px) saturate(160%) !important;
                -webkit-backdrop-filter: blur(15px) saturate(160%) !important;
                border: 1px solid rgba(255, 255, 255, 0.1) !important;
                border-radius: 12px !important;
            }

            /* Language Toggle - Top left corner for portrait */
            .language-toggle {
                top: 15px !important;
                left: 15px !important;
                bottom: auto !important;
                padding: 6px 10px !important;
                font-size: 10px !important;
                scale: 0.5 !important;
            }

            /* Wallet Status Info - More compact for portrait */
            .wallet-status-info {
                top: 15px !important;
                right: 15px !important;
                padding: 6px 10px !important;
                font-size: 10px !important;
                scale: 0.5 !important;
            }

            /* Music Controls - Show in portrait with custom positioning */
            .music-controls {
                display: block !important;
                position: fixed !important;
                top: 60px !important;
                right: 15px !important;
                width: 200px !important;
                height: 80px !important;
                scale: 0.7 !important;
                z-index: 1050 !important;
            }

            /* Left Panel - Minimize for portrait */
            .left-panel {
                left: 10px !important;
                bottom: 10px !important;
                transform: scale(0.8) !important;
                transform-origin: bottom left !important;
            }

            /* Voice Play Button - Smaller for mobile */
            .voice-play-btn {
                padding: 3px 6px !important;
                font-size: 10px !important;
                margin-top: 3px !important;
                margin-left: 3px !important;
            }
        }

        /* Mobile Landscape Layout - Additional Elements */
        @media (orientation: landscape) and (max-width: 1200px) and (max-height: 500px) {

            /* Music Controls - Proper landscape scaling without breaking layout */
            .music-controls {
                width: 280px !important;
                /* Keep original width */
                height: 120px !important;
                /* Keep original height */
                top: 15px !important;
                left: 15px !important;
                padding: 15px !important;
                /* Keep original padding */
                transform: scale(0.75) !important;
                /* Only scale the entire container */
                transform-origin: top left !important;
            }

            /* Don't override internal elements - let them scale naturally with container */

            /* Language Toggle - Compact for landscape */
            .language-toggle {
                bottom: 15px !important;
                left: 15px !important;
                padding: 5px 8px !important;
                font-size: 10px !important;
                transform: scale(0.7) !important;
                transform-origin: bottom left !important;
            }

            .language-btn {
                padding: 3px 6px !important;
                font-size: 9px !important;
            }

            /* Wallet Status Info - Hide or minimize in landscape */
            .wallet-status-info {
                display: none !important;
            }
        }


        /* VRM status information */
        .vrm-status {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            backdrop-filter: blur(10px);
            font-size: 14px;
            z-index: 10;
        }

        /* Hide voice/TTS playing notifications */
        [data-playing-status],
        .playing-indicator,
        .tts-status,
        .voice-status,
        .audio-playing-indicator,
        .speech-playing,
        #playing-indicator,
        #tts-playing,
        #voice-playing,
        .playing-notification {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }

        /* Hide any element containing "Playing" text in top-right area */
        div[style*="position: fixed"][style*="top"][style*="right"]:contains("Playing"),
        div[style*="position: absolute"][style*="top"][style*="right"]:contains("Playing") {
            display: none !important;
        }

        /* Left control panel */
        .left-panel {
            position: fixed;
            left: 20px;
            bottom: 20px;
            width: 250px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 100;
        }

        .panel-section {
            margin-bottom: 20px;
        }

        .panel-section h4 {
            color: #ffeaa7;
            margin-bottom: 10px;
            font-size: 14px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 5px;
        }

        .emotion-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
        }

        .emotion-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .emotion-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .emotion-btn.active {
            background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%);
            color: #2d3436;
        }

        #character-selector,
        #animation-selector {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 12px;
        }

        .play-animation-btn {
            width: 100%;
            margin-top: 10px;
            padding: 8px;
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .play-animation-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(116, 185, 255, 0.4);
        }

        /* Mobile Optimization Notice Modal - Game Style */
        .mobile-notice-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(5px);
        }

        .mobile-notice-modal {
            background: #f4d03f;
            border: 6px solid #2d1b3d;
            border-radius: 20px;
            padding: 0;
            max-width: 320px;
            width: 90%;
            position: relative;
            animation: modalBounceIn 0.5s ease-out;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .mobile-notice-header {
            background: linear-gradient(135deg, #2d1b3d 0%, #4a2c5a 100%);
            color: #f4d03f;
            padding: 15px 20px;
            border-radius: 14px 14px 0 0;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: 3px solid #f4d03f;
            border-bottom: none;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.3);
        }

        .mobile-notice-content {
            padding: 20px;
            color: #2d1b3d;
            font-size: 14px;
            line-height: 1.6;
            text-align: center;
            font-weight: 600;
        }

        .mobile-notice-close {
            background: linear-gradient(135deg, #2d1b3d 0%, #4a2c5a 100%);
            color: #f4d03f;
            border: 3px solid #2d1b3d;
            border-radius: 15px;
            padding: 12px 30px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin: 10px auto 0;
            display: block;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.3);
            box-shadow: 0 4px 0px #1a0f1f, 0 6px 10px rgba(0, 0, 0, 0.3);
        }

        .mobile-notice-close:hover {
            background: linear-gradient(135deg, #4a2c5a 0%, #6c4a7a 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 0px #1a0f1f, 0 8px 15px rgba(0, 0, 0, 0.4);
        }

        .mobile-notice-close:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0px #1a0f1f, 0 3px 5px rgba(0, 0, 0, 0.3);
        }

        @keyframes modalBounceIn {
            0% {
                opacity: 0;
                transform: scale(0.3) translateY(-50px);
            }

            50% {
                opacity: 1;
                transform: scale(1.1) translateY(0);
            }

            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        /* Show mobile notice only on mobile devices */
        @media (max-width: 768px) {
            .mobile-notice-overlay.show {
                display: flex;
            }
        }
    </style>
</head>

<body>
    <!-- Mobile Optimization Notice Modal -->
    <div class="mobile-notice-overlay" id="mobile-notice-overlay">
        <div class="mobile-notice-modal">
            <div class="mobile-notice-header">
                MOBILE NOTICE
            </div>
            <div class="mobile-notice-content">
                The mobile experience is currently being optimized and requires a DApp browser for full functionality.
                <br><br>
                <strong>We recommend using desktop for the best experience.</strong>
            </div>
            <button class="mobile-notice-close" onclick="closeMobileNotice()">CLOSE</button>
        </div>
    </div>

    <!-- Include chat system - AI integration handled by ElizaOS -->
    <script type="module" src="chat-system.js"></script>

    <!-- Mobile Notice Modal JavaScript -->
    <script>
        // Mobile Notice Modal Functions
        window.showMobileNotice = function () {
            const overlay = document.getElementById('mobile-notice-overlay');
            if (overlay && window.innerWidth <= 768) {
                overlay.classList.add('show');
            }
        }

        window.closeMobileNotice = function () {
            const overlay = document.getElementById('mobile-notice-overlay');
            if (overlay) {
                overlay.classList.remove('show');
                // Remember user closed the notice (optional - store in sessionStorage)
                sessionStorage.setItem('mobileNoticeShown', 'true');
            }
        }

        // Show mobile notice on page load for mobile devices
        window.addEventListener('load', () => {
            // Check if notice was already shown in this session
            const noticeShown = sessionStorage.getItem('mobileNoticeShown');
            if (!noticeShown && window.innerWidth <= 768) {
                // Delay showing notice for better UX after page loads
                setTimeout(window.showMobileNotice, 2000);
            }
        });

        // Handle window resize to show/hide notice appropriately
        window.addEventListener('resize', () => {
            const overlay = document.getElementById('mobile-notice-overlay');
            if (overlay && window.innerWidth > 768) {
                overlay.classList.remove('show');
            }
        });
    </script>
    <div class="game-container">
        <!-- Left VRM display area -->
        <div class="vrm-container">
            <!-- Background Video -->
            <video autoplay loop muted playsinline id="bg-video"
                style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: -1;">
                <source src="public/BG/Circle-Cross-Triangle_Yellow-1.mp4" type="video/mp4">
            </video>

            <canvas id="vrm-canvas" class="vrm-canvas"></canvas>

            <!-- AI speech bubble -->
            <div class="ai-speech-bubble" id="ai-speech-bubble" style="display: none;"></div>

            <!-- VRM status info -->
            <div class="vrm-status" id="vrm-status" style="display: none;">
                <div>ðŸŽ­ VRM Status: <span id="vrm-loaded" data-i18n="status.loading">Loading...</span></div>
                <div>ðŸŽ¬ Current Animation: <span id="current-animation" data-i18n="status.none">None</span></div>
                <div>ðŸ˜Š Expression: <span id="current-expression" data-i18n="status.neutral">Neutral</span></div>
                <div>ðŸŽµ Auto Blink: <span id="auto-blinking" data-i18n="status.enabled">Enabled</span></div>
            </div>


            <!-- Retro music player -->
            <div class="music-controls" id="music-controls">
                <div class="music-window-title">
                    Background Music
                    <div class="window-controls">
                        <button class="window-btn minimize-btn"></button>
                        <button class="window-btn maximize-btn"></button>
                        <button class="window-btn close-btn"></button>
                    </div>
                </div>
                <div class="music-player-content">
                    <div class="music-controls-row">
                        <button class="music-control-btn">â®</button>
                        <button class="music-control-btn play-btn" id="music-toggle" onclick="toggleMusic()">â–¶</button>
                        <button class="music-control-btn">â­</button>
                    </div>
                    <div class="volume-control">
                        <input type="range" class="volume-slider" id="volume-slider" min="0" max="100" value="50"
                            onchange="adjustVolume(this.value)">
                        <span class="volume-label" id="volume-label">50</span>
                    </div>
                </div>
            </div>

            <!-- Language switcher -->
            <div class="language-toggle" id="language-toggle">
                <span data-i18n="char.select.language">Language: </span>
                <button class="language-btn" id="lang-en" onclick="switchLanguage('en')">EN</button>
                <button class="language-btn" id="lang-zh" onclick="switchLanguage('zh')">ZH</button>
            </div>


            <!-- Background music element -->
            <audio id="background-music" loop preload="auto" controls style="display: none;">
                <source src="BG/bgm-compressed.mp3" type="audio/mpeg">
                Your browser does not support audio playback.
            </audio>

            <!-- Wallet status (visible when logged in) -->
            <div class="wallet-status-info" id="wallet-status-info" style="display: none;">
                <div class="wallet-avatar">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 21 21">
                        <g fill="none" fill-rule="evenodd" transform="translate(3 4)">
                            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"
                                d="M.5 2.5h12a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2h-10a2 2 0 0 1-2-2zm1-2h9a1 1 0 0 1 1 1v1H.5v-1a1 1 0 0 1 1-1z" />
                            <circle cx="11.5" cy="7.5" r="1" fill="currentColor" />
                        </g>
                    </svg>
                </div>
                <span class="wallet-address" id="wallet-address">Connecting...</span>
                <button class="wallet-disconnect" onclick="disconnectWallet()">Logout</button>
            </div>

        </div>

        <!-- Left control panel removed -->

        <!-- Wallet status -->
        <div class="wallet-status" id="wallet-status" style="display: none;">
            <span>Wallet:</span>
            <span class="wallet-address" id="wallet-address"></span>
            <button class="wallet-disconnect" onclick="disconnectWallet()">Disconnect</button>
        </div>



        <!-- Floating chat window -->
        <!-- Notebook Chat Interface -->
        <div class="notebook-wrapper" id="floating-chat">
            <!-- Simulated Spiral Binding -->
            <div class="spiral-binding">
                <!-- CSS will generate the rings -->
            </div>

            <!-- The Paper Page -->
            <div class="notebook-page">
                <!-- Header: Date & Title -->
                <div class="page-header">
                    <div class="header-date" id="diary-date">Oct 24, 2024</div>
                    <div class="header-title">
                        <span id="character-name">Alice</span>'s Diary
                    </div>
                </div>

                <!-- Main Content Area (Lines) -->
                <div class="page-content" id="chat-window-messages">
                    <!-- Messages go here -->
                </div>

                <!-- Footer: Input -->
                <div class="page-footer">
                    <div class="input-wrapper">
                        <input type="text" id="chat-input-field" class="handwritten-input"
                            placeholder="Write a note...">
                        <button id="send-btn" class="doodle-send-btn">
                            <!-- Simple Arrow Doodle -->
                            <svg viewBox="0 0 24 24" fill="none" class="doodle-arrow">
                                <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" />
                                <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="currentColor" stroke-width="2"
                                    stroke-linecap="round" stroke-linejoin="round" />
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>



    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/",
                "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@2/lib/three-vrm.module.min.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

        // Official Mixamo to VRM bone mapping
        const mixamoVRMRigMap = {
            mixamorigHips: 'hips',
            mixamorigSpine: 'spine',
            mixamorigSpine1: 'chest',
            mixamorigSpine2: 'upperChest',
            mixamorigNeck: 'neck',
            mixamorigHead: 'head',
            mixamorigLeftShoulder: 'leftShoulder',
            mixamorigLeftArm: 'leftUpperArm',
            mixamorigLeftForeArm: 'leftLowerArm',
            mixamorigLeftHand: 'leftHand',
            mixamorigLeftHandThumb1: 'leftThumbMetacarpal',
            mixamorigLeftHandThumb2: 'leftThumbProximal',
            mixamorigLeftHandThumb3: 'leftThumbDistal',
            mixamorigLeftHandIndex1: 'leftIndexProximal',
            mixamorigLeftHandIndex2: 'leftIndexIntermediate',
            mixamorigLeftHandIndex3: 'leftIndexDistal',
            mixamorigLeftHandMiddle1: 'leftMiddleProximal',
            mixamorigLeftHandMiddle2: 'leftMiddleIntermediate',
            mixamorigLeftHandMiddle3: 'leftMiddleDistal',
            mixamorigLeftHandRing1: 'leftRingProximal',
            mixamorigLeftHandRing2: 'leftRingIntermediate',
            mixamorigLeftHandRing3: 'leftRingDistal',
            mixamorigLeftHandPinky1: 'leftLittleProximal',
            mixamorigLeftHandPinky2: 'leftLittleIntermediate',
            mixamorigLeftHandPinky3: 'leftLittleDistal',
            mixamorigRightShoulder: 'rightShoulder',
            mixamorigRightArm: 'rightUpperArm',
            mixamorigRightForeArm: 'rightLowerArm',
            mixamorigRightHand: 'rightHand',
            mixamorigRightHandPinky1: 'rightLittleProximal',
            mixamorigRightHandPinky2: 'rightLittleIntermediate',
            mixamorigRightHandPinky3: 'rightLittleDistal',
            mixamorigRightHandRing1: 'rightRingProximal',
            mixamorigRightHandRing2: 'rightRingIntermediate',
            mixamorigRightHandRing3: 'rightRingDistal',
            mixamorigRightHandMiddle1: 'rightMiddleProximal',
            mixamorigRightHandMiddle2: 'rightMiddleIntermediate',
            mixamorigRightHandMiddle3: 'rightMiddleDistal',
            mixamorigRightHandIndex1: 'rightIndexProximal',
            mixamorigRightHandIndex2: 'rightIndexIntermediate',
            mixamorigRightHandIndex3: 'rightIndexDistal',
            mixamorigRightHandThumb1: 'rightThumbMetacarpal',
            mixamorigRightHandThumb2: 'rightThumbProximal',
            mixamorigRightHandThumb3: 'rightThumbDistal',
            mixamorigLeftUpLeg: 'leftUpperLeg',
            mixamorigLeftLeg: 'leftLowerLeg',
            mixamorigLeftFoot: 'leftFoot',
            mixamorigLeftToeBase: 'leftToes',
            mixamorigRightUpLeg: 'rightUpperLeg',
            mixamorigRightLeg: 'rightLowerLeg',
            mixamorigRightFoot: 'rightFoot',
            mixamorigRightToeBase: 'rightToes',
        };

        // ActorCore to VRM bone mapping
        const actorCoreVRMRigMap = {
            CC_Base_Hip: 'hips',
            CC_Base_Waist: 'spine',
            CC_Base_Spine01: 'chest',
            CC_Base_Spine02: 'upperChest',
            CC_Base_NeckTwist01: 'neck',
            CC_Base_Head: 'head',
            CC_Base_L_Clavicle: 'leftShoulder',
            CC_Base_L_Upperarm: 'leftUpperArm',
            CC_Base_L_Forearm: 'leftLowerArm',
            CC_Base_L_Hand: 'leftHand',
            CC_Base_L_Thumb1: 'leftThumbMetacarpal',
            CC_Base_L_Thumb2: 'leftThumbProximal',
            CC_Base_L_Thumb3: 'leftThumbDistal',
            CC_Base_L_Index1: 'leftIndexProximal',
            CC_Base_L_Index2: 'leftIndexIntermediate',
            CC_Base_L_Index3: 'leftIndexDistal',
            CC_Base_L_Mid1: 'leftMiddleProximal',
            CC_Base_L_Mid2: 'leftMiddleIntermediate',
            CC_Base_L_Mid3: 'leftMiddleDistal',
            CC_Base_L_Ring1: 'leftRingProximal',
            CC_Base_L_Ring2: 'leftRingIntermediate',
            CC_Base_L_Ring3: 'leftRingDistal',
            CC_Base_L_Pinky1: 'leftLittleProximal',
            CC_Base_L_Pinky2: 'leftLittleIntermediate',
            CC_Base_L_Pinky3: 'leftLittleDistal',
            CC_Base_R_Clavicle: 'rightShoulder',
            CC_Base_R_Upperarm: 'rightUpperArm',
            CC_Base_R_Forearm: 'rightLowerArm',
            CC_Base_R_Hand: 'rightHand',
            CC_Base_R_Pinky1: 'rightLittleProximal',
            CC_Base_R_Pinky2: 'rightLittleIntermediate',
            CC_Base_R_Pinky3: 'rightLittleDistal',
            CC_Base_R_Ring1: 'rightRingProximal',
            CC_Base_R_Ring2: 'rightRingIntermediate',
            CC_Base_R_Ring3: 'rightRingDistal',
            CC_Base_R_Mid1: 'rightMiddleProximal',
            CC_Base_R_Mid2: 'rightMiddleIntermediate',
            CC_Base_R_Mid3: 'rightMiddleDistal',
            CC_Base_R_Index1: 'rightIndexProximal',
            CC_Base_R_Index2: 'rightIndexIntermediate',
            CC_Base_R_Index3: 'rightIndexDistal',
            CC_Base_R_Thumb1: 'rightThumbMetacarpal',
            CC_Base_R_Thumb2: 'rightThumbProximal',
            CC_Base_R_Thumb3: 'rightThumbDistal',
            CC_Base_L_Thigh: 'leftUpperLeg',
            CC_Base_L_Calf: 'leftLowerLeg',
            CC_Base_L_Foot: 'leftFoot',
            CC_Base_L_ToeBase: 'leftToes',
            CC_Base_R_Thigh: 'rightUpperLeg',
            CC_Base_R_Calf: 'rightLowerLeg',
            CC_Base_R_Foot: 'rightFoot',
            CC_Base_R_ToeBase: 'rightToes',
        };

        // Complete animation mapping - includes all Mixamo and ActorCore animations
        const animationMap = {
            // Idle animations
            'Breathing Idle': 'mixamo animation/Breathing Idle.fbx',
            'Happy Idle': 'mixamo animation/Happy Idle.fbx',
            // Mixamo animation
            'Acknowledging': 'mixamo animation/Acknowledging.fbx',
            'Agreeing': 'mixamo animation/Agreeing.fbx',
            'Agreeing 2': 'mixamo animation/Agreeing 2.fbx',
            'Angry': 'mixamo animation/Angry.fbx',
            'Bashful': 'mixamo animation/Bashful.fbx',
            'Blow A Kiss': 'mixamo animation/Blow A Kiss.fbx',
            'Cheering': 'mixamo animation/Cheering.fbx',
            'Clapping': 'mixamo animation/Clapping.fbx',
            'Crying': 'mixamo animation/Crying.fbx',
            'Gangnam Style': 'mixamo animation/Gangnam Style.fbx',
            'Happy': 'mixamo animation/Happy.fbx',
            'Hard Head Nod': 'mixamo animation/Hard Head Nod.fbx',
            'Hip Hop Dancing': 'mixamo animation/Hip Hop Dancing.fbx',
            'Hip Hop Dancing 2': 'mixamo animation/Hip Hop Dancing 2.fbx',
            'Joyful Jump': 'mixamo animation/Joyful Jump.fbx',
            'Looking': 'mixamo animation/Looking.fbx',
            'Rejected': 'mixamo animation/Rejected.fbx',
            'Rumba Dancing': 'mixamo animation/Rumba Dancing.fbx',
            'Salute': 'mixamo animation/Salute.fbx',
            'Spin In Place': 'mixamo animation/Spin In Place.fbx',
            'Standing Greeting 2': 'mixamo animation/Standing Greeting 2.fbx',
            'Surprised': 'mixamo animation/Surprised.fbx',
            'Thankful': 'mixamo animation/Thankful.fbx',
            'Thinking': 'mixamo animation/Thinking.fbx',
            'Yawn': 'mixamo animation/Yawn.fbx',
            // ActorCore animation
            'Stand Happy (ActorCore)': 'actorcore animation/stand-happy-f.fbx'
        };

        // Emotion mapping remains unchanged, used for AI auto-trigger
        const emotionAnimationMap = {
            happy: 'mixamo animation/Happy.fbx',
            sad: 'mixamo animation/Crying.fbx',
            angry: 'mixamo animation/Angry.fbx',
            surprised: 'mixamo animation/Surprised.fbx',
            thinking: 'mixamo animation/Thinking.fbx',
            greeting: 'mixamo animation/Standing Greeting 2.fbx',
            agreeing: 'mixamo animation/Agreeing.fbx',
            rejecting: 'mixamo animation/Rejected.fbx',
            clapping: 'mixamo animation/Clapping.fbx',
            cheering: 'mixamo animation/Cheering.fbx',
            thankful: 'mixamo animation/Thankful.fbx',
            bashful: 'mixamo animation/Bashful.fbx',
            neutral: 'mixamo animation/Breathing Idle.fbx',
            breathing: 'mixamo animation/Breathing Idle.fbx',
            kiss: 'mixamo animation/Blow A Kiss.fbx',
            dancing: 'mixamo animation/Hip Hop Dancing.fbx'
        };

        // Keyword emotion mapping
        const keywordEmotionMap = {
            // Happy related
            'å¼€å¿ƒ': 'happy',
            'é«˜å…´': 'happy',
            'å¿«ä¹': 'happy',
            'å“ˆå“ˆ': 'happy',
            'ç¬‘': 'happy',
            'å¥½æ£’': 'happy',
            'å¤ªå¥½äº†': 'happy',
            'å–œæ¬¢': 'happy',
            'çˆ±': 'happy',
            'æ£’': 'cheering',

            // Sad related
            'ä¼¤å¿ƒ': 'sad',
            'éš¾è¿‡': 'sad',
            'å“­': 'sad',
            'ç—›è‹¦': 'sad',
            'å¤±æœ›': 'sad',
            'æ²®ä¸§': 'sad',

            // Angry related
            'ç”Ÿæ°”': 'angry',
            'æ„¤æ€’': 'angry',
            'è®¨åŽŒ': 'angry',
            'çƒ¦': 'angry',
            'æ°”æ­»äº†': 'angry',

            // Surprised related
            'æƒŠè®¶': 'surprised',
            'éœ‡æƒŠ': 'surprised',
            'ä¸æ•¢ç›¸ä¿¡': 'surprised',
            'å¤©å“ª': 'surprised',
            'å“‡': 'surprised',

            // Thinking related
            'æƒ³': 'thinking',
            'æ€è€ƒ': 'thinking',
            'è€ƒè™‘': 'thinking',
            'å—¯': 'thinking',

            // Greeting related
            'ä½ å¥½': 'greeting',
            'å—¨': 'greeting',
            'æ—©ä¸Šå¥½': 'greeting',
            'æ™šä¸Šå¥½': 'greeting',
            'å†è§': 'greeting',

            // Agreement related
            'å¥½çš„': 'agreeing',
            'åŒæ„': 'agreeing',
            'æ˜¯çš„': 'agreeing',
            'å¯¹': 'agreeing',
            'æ²¡é”™': 'agreeing',

            // Rejection related
            'ä¸': 'rejecting',
            'ä¸è¦': 'rejecting',
            'æ‹’ç»': 'rejecting',
            'ä¸è¡Œ': 'rejecting',

            // Thanks related
            'è°¢è°¢': 'thankful',
            'æ„Ÿè°¢': 'thankful',
            'è°¢': 'thankful',

            // Shy related
            'å®³ç¾ž': 'bashful',
            'ä¸å¥½æ„æ€': 'bashful',
            'è„¸çº¢': 'bashful',

            // Kiss related
            'äº²': 'kiss',
            'å»': 'kiss',
            'ä¹ˆä¹ˆ': 'kiss',

            // Dance related
            'è·³èˆž': 'dancing',
            'èˆžè¹ˆ': 'dancing',
            'éŸ³ä¹': 'dancing'
        };

        // Official loadMixamoAnimation function
        function loadMixamoAnimation(url, vrm) {
            const loader = new FBXLoader();
            return loader.loadAsync(url).then((asset) => {
                const clip = THREE.AnimationClip.findByName(asset.animations, 'mixamo.com');

                if (!clip) {
                    throw new Error('æ‰¾ä¸åˆ° Mixamo åŠ¨ç”»data');
                }

                const tracks = [];
                const restRotationInverse = new THREE.Quaternion();
                const parentRestWorldRotation = new THREE.Quaternion();
                const _quatA = new THREE.Quaternion();
                const _vec3 = new THREE.Vector3();

                const motionHipsHeight = asset.getObjectByName('mixamorigHips').position.y;
                const vrmHipsHeight = vrm.humanoid.normalizedRestPose.hips.position[1];
                const hipsPositionScale = vrmHipsHeight / motionHipsHeight;

                clip.tracks.forEach((track) => {
                    const trackSplitted = track.name.split('.');
                    const mixamoRigName = trackSplitted[0];
                    const vrmBoneName = mixamoVRMRigMap[mixamoRigName];
                    const vrmNodeName = vrm.humanoid?.getNormalizedBoneNode(vrmBoneName)?.name;
                    const mixamoRigNode = asset.getObjectByName(mixamoRigName);

                    if (vrmNodeName != null) {
                        const propertyName = trackSplitted[1];

                        mixamoRigNode.getWorldQuaternion(restRotationInverse).invert();
                        mixamoRigNode.parent.getWorldQuaternion(parentRestWorldRotation);

                        if (track instanceof THREE.QuaternionKeyframeTrack) {
                            for (let i = 0; i < track.values.length; i += 4) {
                                const flatQuaternion = track.values.slice(i, i + 4);
                                _quatA.fromArray(flatQuaternion);

                                _quatA
                                    .premultiply(parentRestWorldRotation)
                                    .multiply(restRotationInverse);

                                _quatA.toArray(flatQuaternion);
                                flatQuaternion.forEach((v, index) => {
                                    track.values[index + i] = v;
                                });
                            }

                            tracks.push(
                                new THREE.QuaternionKeyframeTrack(
                                    `${vrmNodeName}.${propertyName}`,
                                    track.times,
                                    track.values.map((v, i) => (vrm.meta?.metaVersion === '0' && i % 2 === 0 ? -v : v)),
                                )
                            );

                        } else if (track instanceof THREE.VectorKeyframeTrack) {
                            const value = track.values.map((v, i) =>
                                (vrm.meta?.metaVersion === '0' && i % 3 !== 1 ? -v : v) * hipsPositionScale
                            );
                            tracks.push(new THREE.VectorKeyframeTrack(`${vrmNodeName}.${propertyName}`, track.times, value));
                        }
                    }
                });

                return new THREE.AnimationClip('vrmAnimation', clip.duration, tracks);
            });
        }

        // ActorCore animation load function
        function loadActorCoreAnimation(url, vrm) {
            const loader = new FBXLoader();
            return loader.loadAsync(url).then((asset) => {
                // ActorCore animation usually the first one is the main animation
                const clip = asset.animations[0];

                if (!clip) {
                    throw new Error('æ‰¾ä¸åˆ° ActorCore åŠ¨ç”»data');
                }

                const tracks = [];
                const restRotationInverse = new THREE.Quaternion();
                const parentRestWorldRotation = new THREE.Quaternion();
                const _quatA = new THREE.Quaternion();
                const _vec3 = new THREE.Vector3();

                // Try to find ActorCore Hip bone to calculate scaling
                let motionHipsHeight = 100; // Default value
                const actorCoreHips = asset.getObjectByName('CC_Base_Hip');
                if (actorCoreHips) {
                    motionHipsHeight = actorCoreHips.position.y;
                }

                const vrmHipsHeight = vrm.humanoid.normalizedRestPose.hips.position[1];
                const hipsPositionScale = vrmHipsHeight / motionHipsHeight;

                // console.log(`ðŸŽ¬ ActorCore animation processing: ${clip.name}, track count: ${clip.tracks.length}`);

                clip.tracks.forEach((track) => {
                    const trackSplitted = track.name.split('.');
                    const actorCoreRigName = trackSplitted[0];
                    const vrmBoneName = actorCoreVRMRigMap[actorCoreRigName];
                    const vrmNodeName = vrm.humanoid?.getNormalizedBoneNode(vrmBoneName)?.name;
                    const actorCoreRigNode = asset.getObjectByName(actorCoreRigName);

                    if (vrmNodeName != null && actorCoreRigNode) {
                        const propertyName = trackSplitted[1];

                        actorCoreRigNode.getWorldQuaternion(restRotationInverse).invert();
                        actorCoreRigNode.parent.getWorldQuaternion(parentRestWorldRotation);

                        if (track instanceof THREE.QuaternionKeyframeTrack) {
                            for (let i = 0; i < track.values.length; i += 4) {
                                const flatQuaternion = track.values.slice(i, i + 4);
                                _quatA.fromArray(flatQuaternion);

                                _quatA
                                    .premultiply(parentRestWorldRotation)
                                    .multiply(restRotationInverse);

                                _quatA.toArray(flatQuaternion);
                                flatQuaternion.forEach((v, index) => {
                                    track.values[index + i] = v;
                                });
                            }

                            tracks.push(
                                new THREE.QuaternionKeyframeTrack(
                                    `${vrmNodeName}.${propertyName}`,
                                    track.times,
                                    track.values.map((v, i) => (vrm.meta?.metaVersion === '0' && i % 2 === 0 ? -v : v)),
                                )
                            );

                        } else if (track instanceof THREE.VectorKeyframeTrack) {
                            const value = track.values.map((v, i) =>
                                (vrm.meta?.metaVersion === '0' && i % 3 !== 1 ? -v : v) * hipsPositionScale
                            );
                            tracks.push(new THREE.VectorKeyframeTrack(`${vrmNodeName}.${propertyName}`, track.times, value));
                        }
                    } else if (!vrmBoneName) {
                        (window.AppConfig?.debug?.warn || console.warn)(`Unmapped ActorCore rig: ${actorCoreRigName}`);
                    }
                });

                // console.log(`âœ… ActorCore animation retargeting completed, generated track count: ${tracks.length}`);
                return new THREE.AnimationClip('actorCoreAnimation', clip.duration, tracks);
            });
        }

        // Scene setup
        const canvas = document.getElementById('vrm-canvas');
        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: true  // Set to true for transparent background to show video
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.NoToneMapping;  // No tone mapping, preserve original colors
        renderer.toneMappingExposure = 1.0;  // Standard exposure
        renderer.outputColorSpace = THREE.SRGBColorSpace;  // Correct color space

        const camera = new THREE.PerspectiveCamera(30.0, 1, 0.1, 20.0);
        // Adjust camera position - full body view
        camera.position.set(0.0, 1.2, 5.0);  // Centered, moderate height, show full body

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.screenSpacePanning = true;
        controls.target.set(0.0, 0.5, 0.0);  // Target character full body center
        controls.update();

        const scene = new THREE.Scene();

        // Background handled by video element, so scene background is transparent
        scene.background = null;

        // Lighting - optimized brightness based on official examples
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(1.0, 1.0, 1.0).normalize();
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.setScalar(1024);
        scene.add(directionalLight);

        // Add supplementary light source to enhance overall brightness
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight.position.set(-1.0, 0.5, -1.0).normalize();
        scene.add(fillLight);

        // Global variables
        let currentVrm = null;
        let currentMixer = null;
        let footShadow = null;

        // Create foot shadow function - reference index.html implementation
        function createFootShadow(vrm) {
            // Remove previous shadow (if exists)
            if (footShadow) {
                scene.remove(footShadow);
                footShadow.geometry.dispose();
                footShadow.material.dispose();
            }

            // Createæ¸å˜åœ†å½¢é˜´å½± - æ¨¡ä»¿index.html
            const shadowCanvas = document.createElement('canvas');
            shadowCanvas.width = 128;
            shadowCanvas.height = 128;
            const context = shadowCanvas.getContext('2d');

            // Create radial gradient shadow
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)'); // Darker at center
            gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.2)'); // Medium transparency
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Transparent at edges

            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);

            const shadowTexture = new THREE.CanvasTexture(shadowCanvas);
            const shadowGeometry = new THREE.PlaneGeometry(2.2, 2.2);
            const shadowMaterial = new THREE.MeshBasicMaterial({
                map: shadowTexture,
                transparent: true,
                alphaTest: 0.001,
                depthWrite: false
            });

            footShadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
            footShadow.rotation.x = -Math.PI / 2;
            footShadow.position.set(0, -0.82, 0); // Directly at foot bottom, consistent with index.html
            scene.add(footShadow);

            AppConfig.debug.log('âœ… Created foot shadow', {
                position: footShadow.position,
                size: '2.2x2.2'
            });
        }

        // Updateé˜´å½±ä½ç½®å‡½æ•°ï¼ˆç”¨äºŽåŠ¨ç”»æ—¶ï¼‰
        function updateFootShadow() {
            if (!footShadow || !currentVrm) return;

            // Keep shadow position fixed at foot bottom
            footShadow.position.x = currentVrm.scene.position.x || 0;
            footShadow.position.y = -0.82; // Fixed height, consistent with index.html
            footShadow.position.z = currentVrm.scene.position.z || 0;
        }
        let currentAction = null;
        let defaultVrmFile = 'Main VRM/Fliza VRM.vrm'; // Default VRM file
        let currentAnimationUrl = null;

        // Expression and AI control variables
        let autoBlinking = true;
        let blinkTimer = 0;
        let blinkFrequency = 3.0;
        let availableExpressions = [];
        let isBlinking = false;
        let blinkDuration = 0.15;
        let aiModeEnabled = true;
        let currentEmotion = 'neutral';
        let isTyping = false;

        // Chat related variables
        let chatHistory = [];

        // Music control variables
        let backgroundMusic = null;
        let isMusicPlaying = false;
        let musicVolume = 0.5; // Default 50% volume

        // Expression related functions
        function getAvailableExpressions(vrm) {
            if (!vrm.expressionManager) return [];

            const expressions = [];
            const presets = ['happy', 'angry', 'sad', 'surprised', 'relaxed', 'blink'];

            presets.forEach(preset => {
                try {
                    const expressionName = vrm.expressionManager.getExpressionTrackName(preset);
                    if (expressionName) {
                        expressions.push(preset);
                    }
                } catch (e) {
                    // Expression does not exist
                }
            });

            (window.AppConfig?.debug?.log || console.log)(`Available expressions: ${expressions.join(', ')}`);
            return expressions;
        }

        function setExpression(expressionName, value) {
            if (!currentVrm || !currentVrm.expressionManager) return;

            try {
                currentVrm.expressionManager.setValue(expressionName, value);
                // console.log(`ðŸ˜Š Setting expression: ${expressionName} = ${value}`);

                // UpdateçŠ¶æ€æ˜¾ç¤º
                if (value > 0.5) {
                    document.getElementById('current-expression').textContent = getEmotionText(expressionName);
                }
            } catch (e) {
                (window.AppConfig?.debug?.warn || console.warn)(`Expression ${expressionName} not available:`, e);
            }
        }

        function resetExpressions() {
            if (!currentVrm || !currentVrm.expressionManager) return;

            availableExpressions.forEach(expr => {
                if (expr !== 'blink') {
                    currentVrm.expressionManager.setValue(expr, 0);
                }
            });

            document.getElementById('current-expression').textContent = 'Neutral';
        }

        // Expression test function
        function testShyExpression() {
            (window.AppConfig?.debug?.log || console.log)('Test bashful expression...');
            (window.AppConfig?.debug?.log || console.log)('Available expressions:', availableExpressions);

            if (!currentVrm || !currentVrm.expressionManager) {
                alert('VRM model is not loaded yet!');
                return;
            }

            // Resetæ‰€æœ‰è¡¨æƒ…
            resetExpressions();

            // Try various shy-related expressions
            const shyExpressions = ['shy', 'embarrassed', 'blush', 'surprised', 'sad'];
            let appliedExpression = null;

            shyExpressions.forEach(expr => {
                if (availableExpressions.includes(expr)) {
                    setExpression(expr, 1.0);
                    appliedExpression = expr;
                    (window.AppConfig?.debug?.log || console.log)(`Applied expression: ${expr}`);
                }
            });

            if (appliedExpression) {
                document.getElementById('current-expression').textContent = `Bashful (${appliedExpression})`;
                // 5ç§’åŽæ¢å¤
                setTimeout(() => {
                    resetExpressions();
                }, 5000);
            } else {
                alert('This VRM model does not support bashful expression.\nAvailable: ' + availableExpressions.join(', '));
            }
        }

        function testHappyExpression() {
            (window.AppConfig?.debug?.log || console.log)('Test happy expression...');

            if (!currentVrm || !currentVrm.expressionManager) {
                alert('VRM model is not loaded yet!');
                return;
            }

            resetExpressions();

            if (availableExpressions.includes('happy')) {
                setExpression('happy', 1.0);
                document.getElementById('current-expression').textContent = 'Happy';
                setTimeout(() => resetExpressions(), 3000);
            } else {
                alert('This VRM model does not support happy expression');
            }
        }

        function testSadExpression() {
            (window.AppConfig?.debug?.log || console.log)('Test sad expression...');

            if (!currentVrm || !currentVrm.expressionManager) {
                alert('VRM model is not loaded yet!');
                return;
            }

            resetExpressions();

            if (availableExpressions.includes('sad')) {
                setExpression('sad', 1.0);
                document.getElementById('current-expression').textContent = 'Sad';
                setTimeout(() => resetExpressions(), 3000);
            } else {
                alert('This VRM model does not support sad expression');
            }
        }

        function resetAllExpressions() {
            (window.AppConfig?.debug?.log || console.log)('Reset all expressions...');
            resetExpressions();
        }

        function performBlink() {
            if (!currentVrm || !availableExpressions.includes('blink') || isBlinking) return;

            isBlinking = true;
            const startTime = performance.now();

            function animateBlink() {
                const elapsed = (performance.now() - startTime) / 1000;
                const progress = elapsed / blinkDuration;

                if (progress < 0.5) {
                    const blinkValue = Math.sin(progress * Math.PI * 2) * 0.5 + 0.5;
                    setExpression('blink', blinkValue);
                } else if (progress < 1.0) {
                    const blinkValue = Math.sin((1 - progress) * Math.PI * 2) * 0.5 + 0.5;
                    setExpression('blink', blinkValue);
                } else {
                    setExpression('blink', 0);
                    isBlinking = false;
                    return;
                }

                requestAnimationFrame(animateBlink);
            }

            animateBlink();
        }

        // Animation loading function
        // Idle animationsç›¸å…³å˜é‡
        let idleAnimationUrl = 'mixamo animation/Breathing Idle.fbx';
        let idleAction = null;
        let returnToIdleTimer = null;

        async function loadAnimation(animationUrl, emotionName = null) {
            if (!currentVrm) return;

            try {
                // Clear previous return to idle timer
                if (returnToIdleTimer) {
                    clearTimeout(returnToIdleTimer);
                    returnToIdleTimer = null;
                }

                currentAnimationUrl = animationUrl;

                // Determine if it is idle animation
                const isIdleAnimation = animationUrl === idleAnimationUrl || animationUrl.includes('Breathing Idle');

                // Determine if it is ActorCore or Mixamo animation
                const isActorCore = animationUrl.includes('actorcore animation');
                const clip = isActorCore ?
                    await loadActorCoreAnimation(animationUrl, currentVrm) :
                    await loadMixamoAnimation(animationUrl, currentVrm);

                if (currentMixer) {
                    const newAction = currentMixer.clipAction(clip);
                    newAction.reset().play();
                    newAction.timeScale = 1.0;

                    // If idle animation, set to loop
                    if (isIdleAnimation) {
                        newAction.loop = THREE.LoopRepeat;
                        idleAction = newAction;
                    } else {
                        // Non-idle animations set to play once
                        newAction.loop = THREE.LoopOnce;
                        newAction.clampWhenFinished = true;
                    }

                    if (currentAction && currentAction !== newAction) {
                        currentAction.crossFadeTo(newAction, 1.0, false);
                    }

                    currentAction = newAction;

                    // If not idle animation, set timer to return to idle
                    if (!isIdleAnimation) {
                        // Get animation duration, return to idle after animation ends
                        const animationDuration = clip.duration * 1000; // Convert to milliseconds
                        returnToIdleTimer = setTimeout(() => {
                            // console.log('ðŸ”„ Return to idle animation');
                            loadAnimation(idleAnimationUrl);
                        }, animationDuration + 500); // Return to idle 0.5 seconds after animation ends
                    }
                }

                // UpdateçŠ¶æ€æ˜¾ç¤º
                const animationName = animationUrl.split('/').pop().split('.')[0];
                document.getElementById('current-animation').textContent = animationName;

                if (emotionName) {
                    currentEmotion = emotionName;
                    // Set expression simultaneously
                    if (availableExpressions.includes(emotionName)) {
                        setExpression(emotionName, 1.0);
                        setTimeout(() => {
                            setExpression(emotionName, 0);
                        }, 2000);
                    }
                }

                // console.log(`ðŸŽ¬ Animation loaded successfully: ${animationName} (${isActorCore ? 'ActorCore' : 'Mixamo'})`);

            } catch (error) {
                console.error('âŒ Animation load failed:', error);
            }
        }

        // VRM characteråˆ—è¡¨
        const vrmCharacters = {
            'Alice': 'Main VRM/Alice.vrm',
            'Fliza VRM': 'Main VRM/Fliza VRM.vrm',
            'QuQu_U': 'Main VRM/QuQu_U.vrm',
            'Ash1.0': 'Main VRM/Ash1.0.vrm',
            'CH_001_imiut': 'Main VRM/CH_001_imiut_v1.01.vrm',
            'CH_007_unkt': 'Main VRM/CH_007_unkt_off_bonnet_v1_00.vrm',
            'Elinyaa': 'Main VRM/Elinyaa.vrm',
            'IMERIS': 'Main VRM/IMERIS.vrm',
            'Lena': 'Main VRM/Lena_ver1.02(VRM).vrm',
            'Lilium': 'Main VRM/Lilium_ver1.01 (VRM).vrm',
            'M_CH_06_Shiratori': 'Main VRM/M_CH_06_Shiratori_v1.00.vrm',
            'Maple': 'Main VRM/Maple_1.0.vrm',
            'NEKONA': 'Main VRM/NEKONA.01.vrm',
            'NecoMaid_Premium': 'Main VRM/NecoMaid_Premium.vrm',
            'RINDO_Full': 'Main VRM/RINDO_Full.vrm',
            'Rainy': 'Main VRM/Rainy_1.00.vrm',
            'NEKO': 'Main VRM/NEKO.vrm',
            'Vivi_model': 'Main VRM/Vivi_model.vrm',
            'Wolf': 'Main VRM/Wolf_ver1.00(VRM).vrm',
            'Wolferia': 'Main VRM/Wolferia.vrm',
            'YM_CH_03_Notia': 'Main VRM/YM_CH_03_Notia_v1.01.vrm',
            'Yawl_Dress': 'Main VRM/Yawl_Dress.vrm',
            'Yuu uwaginasi': 'Main VRM/Yuu uwaginasi.vrm',
            'Yuu': 'Main VRM/Yuu.vrm',
            'kyoko': 'Main VRM/kyoko.vrm',
            'miru': 'Main VRM/miru.vrm',
            'sikirei_Rei': 'Main VRM/sikirei_Rei_VRM.vrm'
        };

        let currentCharacterName = 'Fliza VRM';

        // VRM loadå‡½æ•°
        function loadVRM(characterName = null) {
            let vrmPath;

            if (characterName) {
                vrmPath = vrmCharacters[characterName];
                if (!vrmPath) {
                    // Try to find character by name mapping for index.html compatibility
                    const nameToVrmKey = {
                        'Neco': 'NEKO',
                        'Nekona': 'NEKONA',
                        'Alice': 'Alice',
                        'Ash': 'Ash1.0',
                        'Fliza': 'Fliza VRM',
                        'QuQu': 'QuQu_U',
                        'Imeris': 'IMERIS',
                        'Rindo': 'RINDO_Full',
                        'Notia': 'YM_CH_03_Notia',
                        'Yawl': 'Yawl_Dress',
                        'Vivi': 'Vivi_model'
                    };

                    const vrmKey = nameToVrmKey[characterName];
                    if (vrmKey && vrmCharacters[vrmKey]) {
                        vrmPath = vrmCharacters[vrmKey];
                        characterName = vrmKey; // Update to VRM key for consistency
                    } else {
                        console.error('âŒ Character not found:', characterName);
                        return;
                    }
                }
            } else {
                // Use default or selected character file
                vrmPath = defaultVrmFile;
                // Get selected character info from localStorage
                const selectedCharacterData = localStorage.getItem('selectedCharacter');
                if (selectedCharacterData) {
                    const character = JSON.parse(selectedCharacterData);
                    // Use the file path directly if available, otherwise use name mapping
                    if (character.file) {
                        vrmPath = character.file;
                        characterName = character.name || 'Fliza';

                        // Find the VRM key that matches this file path
                        const vrmKey = Object.keys(vrmCharacters).find(key => vrmCharacters[key] === character.file);
                        if (vrmKey) {
                            characterName = vrmKey;
                        }
                    } else {
                        characterName = character.name || 'Fliza';
                    }
                } else {
                    characterName = 'Fliza';
                }
            }

            // console.log('ðŸŽ® VRM loading debug info:');
            // console.log('- characterName:', characterName);
            // console.log('- vrmPath:', vrmPath);
            // console.log('- defaultVrmFile:', defaultVrmFile);

            if (!vrmPath) {
                console.error('âŒ VRM file path is empty');
                updateVRMStatus('Failed: empty file path');
                return;
            }

            currentCharacterName = characterName;
            updateVRMStatus('Loading...');

            const loader = new GLTFLoader();
            loader.crossOrigin = 'anonymous';

            // Don't use helperRoot, keep consistent with index.html
            loader.register((parser) => {
                return new VRMLoaderPlugin(parser);
            });

            loader.load(
                vrmPath,
                (gltf) => {
                    // console.log('ðŸŽ‰ VRM file loaded successfully!', gltf);
                    const vrm = gltf.userData.vrm;
                    // console.log('ðŸ“¦ VRM object:', vrm);

                    // Use VRM v2 compatible optimization method
                    VRMUtils.removeUnnecessaryVertices(gltf.scene);
                    // VRMUtils.combineSkeletons åœ¨ v2 ä¸­å·²ç§»é™¤
                    // VRMUtils.combineMorphs åœ¨ v2 ä¸­å·²ç§»é™¤

                    if (currentVrm) {
                        scene.remove(currentVrm.scene);
                        VRMUtils.deepDispose(currentVrm.scene);
                    }

                    // Clean up previous shadows
                    if (footShadow) {
                        scene.remove(footShadow);
                        footShadow.geometry.dispose();
                        footShadow.material.dispose();
                        footShadow = null;
                    }

                    currentVrm = vrm;
                    scene.add(vrm.scene);

                    // VRMæ¨¡åž‹å¤§å°å’Œä½ç½®Setting - ä¸Žindex.htmlä¸€è‡´
                    vrm.scene.scale.set(1.45, 1.45, 1.45);  // Same scaling ratio as character selection page

                    // Move VRM model position down, closer to bottom boundary
                    vrm.scene.position.y = -0.8;  // Same position as character selection page

                    // Createè„šåº•é˜´å½±
                    createFootShadow(vrm);

                    currentMixer = new THREE.AnimationMixer(currentVrm.scene);

                    vrm.scene.traverse((obj) => {
                        obj.frustumCulled = false;
                    });

                    // VRMUtils.rotateVRM0 may be unnecessary or changed in v2
                    try {
                        VRMUtils.rotateVRM0(vrm);
                    } catch (error) {
                        (window.AppConfig?.debug?.warn || console.warn)('VRMUtils.rotateVRM0 not available; skip (VRM v2 compat)');
                    }

                    availableExpressions = getAvailableExpressions(vrm);

                    // Updateå…¨å±€å˜é‡
                    window.currentVrm = currentVrm;
                    window.availableExpressions = availableExpressions;

                    updateVRMStatus('âœ… Loaded');

                    // Updatecharacteråç§°æ˜¾ç¤º
                    const characterNameElement = document.getElementById('character-name');
                    if (characterNameElement) {
                        characterNameElement.textContent = characterName;
                    }

                    // Play idle animation by default
                    loadAnimation(idleAnimationUrl);

                    // console.log('ðŸŽ­ VRM loaded:', vrm);

                    // InitializeAIchat system
                    onVRMLoadComplete(currentCharacterName, vrmPath);
                },
                (progress) => {
                    const percent = (100.0 * (progress.loaded / progress.total)).toFixed(1);
                    // console.log(`ðŸ“Š VRM loading: ${percent}%`, progress);
                    updateVRMStatus(`Loading... ${percent}%`);
                },
                (error) => {
                    console.error('âŒ VRM load failed:', error);
                    console.error('âŒ Detail:', error.message, error.stack);
                    console.error('âŒ VRM path attempted:', vrmPath);
                    console.error('âŒ Current location:', window.location.href);
                    updateVRMStatus(`âŒ Failed: ${error.message || error}`);
                }
            );
        }

        // Status update function
        function updateVRMStatus(status) {
            document.getElementById('vrm-loaded').textContent = status;
        }

        function getEmotionText(emotion) {
            const emotionMap = {
                happy: 'å¼€å¿ƒ',
                sad: 'ä¼¤å¿ƒ',
                angry: 'ç”Ÿæ°”',
                surprised: 'æƒŠè®¶',
                thinking: 'æ€è€ƒ',
                neutral: 'ä¸­æ€§',
                bashful: 'å®³ç¾ž'
            };
            return emotionMap[emotion] || 'ä¸­æ€§';
        }

        // AI èŠå¤©å‡½æ•°
        function analyzeMessage(message) {
            // Simple keyword emotion analysis
            for (const [keyword, emotion] of Object.entries(keywordEmotionMap)) {
                if (message.includes(keyword)) {
                    return emotion;
                }
            }
            return 'neutral';
        }

        function generateAIResponse(userMessage) {
            // Simple AI reply system (can connect to real AI API later)
            const responses = {
                greeting: [
                    "Hello! Nice to meet you~ ðŸ’•",
                    "Hi! How's your day going?",
                    "Welcome back! I've been waiting for you~"
                ],
                happy: [
                    "Wow! You look so happy! I'm happy too~ ðŸ˜Š",
                    "Great! Your joy is contagious!",
                    "Seeing you happy makes me want to dance!"
                ],
                sad: [
                    "Don't be sad, I'll always be here with you... ðŸ˜¢",
                    "Although it's hard now, everything will get better!",
                    "Come, let me give you a hug~"
                ],
                angry: [
                    "Don't be angry, take a deep breath~ ðŸ˜¤",
                    "I know you're angry, but anger can hurt your body",
                    "Tell me what happened, I'll help you figure it out!"
                ],
                surprised: [
                    "Really?! That's so surprising! ðŸ˜²",
                    "Wow! Didn't expect that!",
                    "That's really unexpected!"
                ],
                thinking: [
                    "Hmm...let me think about that... ðŸ¤”",
                    "That's definitely worth thinking about",
                    "You're right, I'm thinking about that too"
                ],
                love: [
                    "I like you too~ ðŸ’•",
                    "Really? I'm so happy!",
                    "You're making me blush~"
                ],
                default: [
                    "Mm-hmm, I understand~",
                    "I see, that's interesting!",
                    "You make a good point~",
                    "I think so too!",
                    "What do you think?"
                ]
            };

            // Detect special keywords
            if (userMessage.includes('love') || userMessage.includes('like you') || userMessage.includes('I love you')) {
                return responses.love[Math.floor(Math.random() * responses.love.length)];
            }

            const emotion = analyzeMessage(userMessage);
            const responseArray = responses[emotion] || responses.default;
            return responseArray[Math.floor(Math.random() * responseArray.length)];
        }

        // Character class name mapping
        function getCharacterClassName(characterName) {
            const nameMapping = {
                'èŠ™èŽ‰èŽŽ': 'character-fliza',
                'Fliza': 'character-fliza',
                'Alice': 'character-alice',
                'Ash': 'character-ash',
                'Bobo': 'character-bobo',
                'Elinyaa': 'character-elinyaa',
                'Imeris': 'character-imeris',
                'Kyoko': 'character-kyoko',
                'Lena': 'character-lena',
                'Lilium': 'character-lilium',
                'Maple': 'character-maple',
                'Miru': 'character-miru',
                'Miumiu': 'character-miumiu',
                'Neco': 'character-neco',
                'Nekona': 'character-nekona',
                'Notia': 'character-notia',
                'Ququ': 'character-ququ',
                'Rainy': 'character-rainy',
                'Rindo': 'character-rindo',
                'Sikirei': 'character-sikirei',
                'Vivi': 'character-vivi',
                'Wolf': 'character-wolf',
                'Wolferia': 'character-wolferia',
                'Yawl': 'character-yawl',
                'Yuu': 'character-yuu',
                'Zwei': 'character-zwei'
            };
            return nameMapping[characterName] || 'character-alice'; // Default to Alice
        }

        // Chat UI functions

        // Updateæµå¼æ¶ˆæ¯å†…å®¹
        function updateStreamingMessageUI(messageId, content) {
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageElement) {
                const messageContent = messageElement.querySelector('.message-text');
                if (messageContent) {
                    messageContent.textContent = content;

                    // Add typing effect cursor
                    if (!content.endsWith('|')) {
                        messageContent.textContent += '|';
                        setTimeout(() => {
                            if (messageContent.textContent.endsWith('|')) {
                                messageContent.textContent = content;
                            }
                        }, 500);
                    }

                    // Keep scrolled to bottom
                    const messagesContainer = document.getElementById('chat-window-messages');
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;

                    // Only update dialogue bubble text, don't restart animation
                    updateSpeechBubbleContent(content);
                }
            }
        }

        // Speech bubble state management
        let speechBubbleState = {
            isActive: false,
            currentAnimation: null,
            timeoutId: null
        };

        // Show AI dialogue bubble
        function showSpeechBubble(text) {
            // console.log('ðŸ—¨ï¸ showSpeechBubble called with text:', text);
            const bubble = document.getElementById('ai-speech-bubble');

            if (!bubble) {
                console.error('âŒ Speech bubble element not found!');
                return;
            }

            // Clear previous state
            if (speechBubbleState.timeoutId) {
                clearTimeout(speechBubbleState.timeoutId);
            }

            bubble.style.display = 'block';
            bubble.style.animation = 'bubbleFadeIn 0.5s forwards';
            speechBubbleState.isActive = true;

            // Typewriter effect - display character by character
            let currentIndex = 0;
            bubble.textContent = '';

            function typeText() {
                if (currentIndex < text.length && speechBubbleState.isActive) {
                    bubble.textContent += text[currentIndex];
                    currentIndex++;
                    speechBubbleState.timeoutId = setTimeout(typeText, 100);
                } else if (speechBubbleState.isActive) {
                    // After text display completes, stay longer
                    const displayTime = Math.max(5000, text.length * 200);

                    // console.log(`ðŸ’¬ Subtitle bubble display time: ${displayTime}ms (text length: ${text.length}characters)`);

                    speechBubbleState.timeoutId = setTimeout(() => {
                        if (speechBubbleState.isActive) {
                            bubble.style.animation = 'bubbleFadeOut 1s forwards';
                            speechBubbleState.timeoutId = setTimeout(() => {
                                bubble.style.display = 'none';
                                speechBubbleState.isActive = false;
                            }, 1000);
                        }
                    }, displayTime);
                }
            }

            // Startæ‰“charactersæ•ˆæžœ
            speechBubbleState.timeoutId = setTimeout(typeText, 200); // Start typing 200ms after bubble appears
        }

        // Speech bubble streaming update state
        let bubbleStreamingState = {
            isStreaming: false,
            pendingText: '',
            streamStartTime: null
        };

        // Updateå¯¹è¯æ°”æ³¡å†…å®¹ï¼ˆæµå¼æ›´æ–°æ—¶ä½¿ç”¨ï¼Œä¸é‡å¯åŠ¨ç”»ï¼‰
        function updateSpeechBubbleContent(text) {
            // Mark as streaming update state
            if (!bubbleStreamingState.isStreaming) {
                bubbleStreamingState.isStreaming = true;
                bubbleStreamingState.streamStartTime = Date.now();
                console.log('ðŸŽ¬ Starting streaming speech bubble update');
            }

            // Save latest complete text
            bubbleStreamingState.pendingText = text;

            // Setupå»¶è¿Ÿæ˜¾ç¤ºï¼Œé¿å…é¢‘ç¹æ›´æ–°
            if (bubbleStreamingState.timeoutId) {
                clearTimeout(bubbleStreamingState.timeoutId);
            }

            bubbleStreamingState.timeoutId = setTimeout(() => {
                // If still in streaming update, check if should display
                const timeSinceStart = Date.now() - bubbleStreamingState.streamStartTime;

                // If streaming update has stopped for more than 500ms, consider completed
                if (timeSinceStart > 500) {
                    console.log('âœ¨ Streaming update completed, showing final speech bubble');
                    bubbleStreamingState.isStreaming = false;
                    showSpeechBubble(bubbleStreamingState.pendingText);
                }
            }, 500); // Delay 500ms waiting for streaming update to complete
        }


        // The entire sendMessage function has been replaced by the new elizaChatSystem.handleSendMessage() method.
        // This is called directly from sendChatMessage() and handleChatKeyPress().
        async function sendMessage() {
            if (window.elizaChatSystem) {
                window.elizaChatSystem.handleSendMessage();
            } else {
                console.error('âŒ ElizaOS Chat System not initialized.');
            }
        }

        // Save chat records (simple version)
        function saveChatHistory(userId, characterId, userMessage, aiResponse) {
            try {
                const historyKey = `chat_history_${userId}_${characterId}`;
                let history = JSON.parse(localStorage.getItem(historyKey) || '[]');

                // Add new conversation
                history.push({
                    timestamp: new Date().toISOString(),
                    user: userMessage,
                    ai: aiResponse
                });

                // Only keep recent 50 conversations
                if (history.length > 50) {
                    history = history.slice(-50);
                }

                localStorage.setItem(historyKey, JSON.stringify(history));
                console.log('ðŸ’¾ Chat history saved');

            } catch (error) {
                console.error('Failed to save chat history:', error);
            }
        }

        function sendChatMessage() {
            sendMessage();
        }

        function handleChatKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        // Emotion trigger function
        function triggerEmotion(emotion) {
            if (!currentVrm) return;

            // console.log(`ðŸŽ­ Triggering emotion: ${emotion}`);

            // ResetæŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.emotion-btn').forEach(btn => btn.classList.remove('active'));

            // Activate corresponding button
            const emotionBtns = document.querySelectorAll('.emotion-btn');
            emotionBtns.forEach(btn => {
                if (btn.textContent.includes(getEmotionText(emotion))) {
                    btn.classList.add('active');
                }
            });

            if (emotion === 'neutral') {
                resetExpressions();
                loadAnimation(idleAnimationUrl);
                return;
            }

            // Loadå¯¹åº”åŠ¨ç”»
            if (emotionAnimationMap[emotion]) {
                loadAnimation(emotionAnimationMap[emotion], emotion);
            }

            // Setupè¡¨æƒ…
            if (availableExpressions.includes(emotion)) {
                resetExpressions();
                setExpression(emotion, 1.0);

                // 3ç§’åŽæ¢å¤ä¸­æ€§è¡¨æƒ…
                setTimeout(() => {
                    setExpression(emotion, 0);
                    document.getElementById('current-expression').textContent = 'ä¸­æ€§';
                }, 3000);
            }
        }

        function toggleAutoMode() {
            aiModeEnabled = !aiModeEnabled;
            document.getElementById('ai-mode-status').textContent = aiModeEnabled ? i18n.t('status.enabled') : i18n.t('status.disabled');
            document.getElementById('ai-status').innerHTML = aiModeEnabled ?
                '<span class="online-indicator"></span>' + i18n.t('status.ai.smart') :
                '<span class="online-indicator"></span>' + i18n.t('status.manual');
        }

        function toggleDebugMode() {
            helperRoot.visible = !helperRoot.visible;
            console.log(`ðŸ¦´ Bone debug mode: ${helperRoot.visible ? 'enabled' : 'disabled'}`);
        }

        // Music control functions
        function initBackgroundMusic() {
            backgroundMusic = document.getElementById('background-music');

            if (backgroundMusic) {
                backgroundMusic.volume = musicVolume;
                // console.log('ðŸŽµ Background music element found, volume set to:', musicVolume);

                // Initialize button state to match isMusicPlaying
                updateMusicButton();

                // Music loaded successfully event
                backgroundMusic.addEventListener('canplaythrough', () => {
                    console.log('ðŸŽµ Background music loading complete');
                });

                // Music loading error event
                backgroundMusic.addEventListener('error', (e) => {
                    console.warn('âš ï¸ Background music loading failed:', e);
                    console.warn('âš ï¸ Audio source:', backgroundMusic.src || backgroundMusic.currentSrc);
                    document.getElementById('music-controls').style.display = 'none';
                });

                // Add loadstart event for debugging
                backgroundMusic.addEventListener('loadstart', () => {
                    // console.log('ðŸŽµ Started loading background music from:', backgroundMusic.src || backgroundMusic.currentSrc);
                });

                // Try auto play
                playBackgroundMusic();
            } else {
                console.error('âŒ Background music element not found');
            }
        }

        function playBackgroundMusic() {
            if (backgroundMusic) {
                backgroundMusic.play().then(() => {
                    isMusicPlaying = true;
                    updateMusicButton();
                    // console.log('ðŸŽµ Background music started playing');
                    // Remove fixed background music message
                }).catch(error => {
                    console.log('ðŸŽµ Auto-play blocked by browser, waiting for user interaction');
                    isMusicPlaying = false;
                    updateMusicButton();

                    // Add user interaction listeners to start music
                    function startMusicOnInteraction() {
                        if (backgroundMusic && !isMusicPlaying) {
                            backgroundMusic.play().then(() => {
                                isMusicPlaying = true;
                                updateMusicButton();
                                // console.log('ðŸŽµ Background music started after user interaction');
                            }).catch(e => {
                                console.log('âš ï¸ Could not start background music:', e);
                            });
                        }
                        // Remove event listeners after first successful play
                        document.removeEventListener('click', startMusicOnInteraction);
                        document.removeEventListener('keydown', startMusicOnInteraction);
                        document.removeEventListener('touchstart', startMusicOnInteraction);
                    }

                    // Add event listeners for user interaction
                    document.addEventListener('click', startMusicOnInteraction);
                    document.addEventListener('keydown', startMusicOnInteraction);
                    document.addEventListener('touchstart', startMusicOnInteraction);
                });
            }
        }

        function toggleMusic() {
            if (!backgroundMusic) return;

            if (isMusicPlaying) {
                backgroundMusic.pause();
                isMusicPlaying = false;
            } else {
                backgroundMusic.play().then(() => {
                    isMusicPlaying = true;
                }).catch(error => {
                    console.error('ðŸŽµ Music playback failed:', error);
                });
            }
            updateMusicButton();
        }

        function adjustVolume(value) {
            musicVolume = value / 100;
            if (backgroundMusic) {
                backgroundMusic.volume = musicVolume;
            }
            document.getElementById('volume-label').textContent = value + '%';

            // Update volume icon based on volume
            const volumeIcon = document.querySelector('.volume-control span');
            if (value == 0) {
                volumeIcon.textContent = 'ðŸ”‡';
            } else if (value < 30) {
                volumeIcon.textContent = 'ðŸ”ˆ';
            } else if (value < 70) {
                volumeIcon.textContent = 'ðŸ”‰';
            } else {
                volumeIcon.textContent = 'ðŸ”Š';
            }
        }

        function updateMusicButton() {
            const button = document.getElementById('music-toggle');
            if (isMusicPlaying) {
                button.textContent = 'â¸';
                button.classList.remove('paused');
            } else {
                button.textContent = 'â–¶';
                button.classList.add('paused');
            }
        }

        // Language switch function - globally accessible
        window.switchLanguage = function (lang) {
            if (window.i18n) {
                window.i18n.switchLanguage(lang);
            }
        };

        // Initialize language switcher
        function initLanguageToggle() {
            if (window.i18n) {
                const currentLang = window.i18n.getCurrentLanguage();
                const enBtn = document.getElementById('lang-en');
                const zhBtn = document.getElementById('lang-zh');

                if (enBtn && zhBtn) {
                    enBtn.classList.toggle('active', currentLang === 'en');
                    zhBtn.classList.toggle('active', currentLang === 'zh');
                }
            }
        }

        function initAnimationSelector() {
            const selector = document.getElementById('animation-selector');
            // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æžœä¸å­˜åœ¨åˆ™è·³è¿‡
            if (!selector) {
                // console.log('ðŸŽ­ Animation selector element not found, skipping initialization');
                return;
            }
            // ClearçŽ°æœ‰é€‰é¡¹
            selector.innerHTML = '<option value="">' + i18n.t('panel.select.animation') + '</option>';

            // Add all animation options
            Object.keys(animationMap).sort().forEach(animationName => {
                const option = document.createElement('option');
                option.value = animationName;
                option.textContent = animationName;
                selector.appendChild(option);
            });
        }

        function initCharacterSelector() {
            const selector = document.getElementById('character-selector');
            // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æžœä¸å­˜åœ¨åˆ™è·³è¿‡
            if (!selector) {
                // console.log('ðŸŽ­ Character selector element not found, skipping initialization');
                return;
            }
            // ClearçŽ°æœ‰é€‰é¡¹
            selector.innerHTML = '<option value="">' + i18n.t('panel.select.character') + '</option>';

            // Add all character options
            Object.keys(vrmCharacters).sort().forEach(characterName => {
                const option = document.createElement('option');
                option.value = characterName;
                option.textContent = characterName;
                selector.appendChild(option);
            });

            // Setupé»˜è®¤é€‰ä¸­çš„character
            selector.value = currentCharacterName;
        }

        function changeCharacter() {
            const selector = document.getElementById('character-selector');
            const selectedCharacter = selector.value;

            if (!selectedCharacter) {
                return;
            }

            if (selectedCharacter === currentCharacterName) {
                return;
            }

            console.log(`ðŸ‘¤ Switching character: ${currentCharacterName} -> ${selectedCharacter}`);

            // UpdateèŠå¤©å¤´éƒ¨çš„characteråç§°
            const characterNames = {
                'Fliza VRM': 'èŠ™èŽ‰èŽŽ',
                'QuQu_U': 'QuQu',
                'Ash1.0': 'Ash',
                'CH_001_imiut': 'Imiut',
                'CH_007_unkt': 'Unkt',
                'Elinyaa': 'Elinyaa',
                'IMERIS': 'Imeris',
                'Lena': 'Lena',
                'Lilium': 'Lilium',
                'M_CH_06_Shiratori': 'Shiratori',
                'Maple': 'Maple',
                'NEKONA': 'Nekona',
                'NecoMaid_Premium': 'NecoMaid',
                'RINDO_Full': 'Rindo',
                'Rainy': 'Rainy',
                'NEKO': 'Neco',
                'Vivi_model': 'Vivi',
                'Wolf': 'Wolf',
                'Wolferia': 'Wolferia',
                'YM_CH_03_Notia': 'Notia',
                'Yawl_Dress': 'Yawl',
                'Yuu uwaginasi': 'Yuu',
                'Yuu': 'Yuu',
                'kyoko': 'Kyoko',
                'miru': 'Miru',
                'sikirei_Rei': 'Rei'
            };

            const displayName = characterNames[selectedCharacter] || selectedCharacter;
            document.querySelector('.chat-user-details h1').textContent = displayName;

            // Loadæ–°character
            loadVRM(selectedCharacter);

            // Setupcharacterå¤´åƒ
            setCharacterAvatar(selectedCharacter);

            // Add character switch message
            // Welcome message handled by ElizaOS system
        }

        // Setupcharacterå¤´åƒçš„å‡½æ•°
        let lastSetAvatar = null; // Prevent repeatedly setting same avatar
        function setCharacterAvatar(characterKey) {
            // Prevent repeatedly setting same avatar
            if (lastSetAvatar === characterKey) {
                return;
            }
            lastSetAvatar = characterKey;

            // Character name to CSS class mapping (supports two formats: id and VRM filename)
            const characterToClass = {
                // ID-based mapping (from index.html)
                'alice': 'character-alice',
                'ash': 'character-ash',
                'elinyaa': 'character-elinyaa',
                'fliza': 'character-fliza',
                'imeris': 'character-imeris',
                'kyoko': 'character-kyoko',
                'lena': 'character-lena',
                'lilium': 'character-lilium',
                'maple': 'character-maple',
                'miru': 'character-miru',
                'miumiu': 'character-miumiu',
                'neco': 'character-neco',
                'nekona': 'character-nekona',
                'notia': 'character-notia',
                'ququ': 'character-ququ',
                'rainy': 'character-rainy',
                'rindo': 'character-rindo',
                'sikirei': 'character-sikirei',
                'vivi': 'character-vivi',
                'wolf': 'character-wolf',
                'wolferia': 'character-wolferia',
                'yawl': 'character-yawl',
                'yuu': 'character-yuu',
                'zwei': 'character-zwei',
                'bobo': 'character-bobo',
                // VRM filename-based mapping (for character switching)
                'Fliza VRM': 'character-fliza',
                'QuQu_U': 'character-ququ',
                'Ash1.0': 'character-ash',
                'CH_001_imiut': 'character-imeris',
                'Elinyaa': 'character-elinyaa',
                'IMERIS': 'character-imeris',
                'Lena': 'character-lena',
                'Lilium': 'character-lilium',
                'Maple': 'character-maple',
                'NEKONA': 'character-nekona',
                'NecoMaid_Premium': 'character-neco',
                'RINDO_Full': 'character-rindo',
                'Rainy': 'character-rainy',
                'NEKO': 'character-neco',
                'Vivi_model': 'character-vivi',
                'Wolf': 'character-wolf',
                'Wolferia': 'character-wolferia',
                'YM_CH_03_Notia': 'character-notia',
                'Yawl_Dress': 'character-yawl',
                'Yuu uwaginasi': 'character-yuu',
                'Yuu': 'character-yuu',
                'kyoko': 'character-kyoko',
                'miru': 'character-miru',
                'sikirei_Rei': 'character-sikirei'
            };

            // Remove all previous character classes
            const body = document.body;
            const existingClasses = body.className.split(' ').filter(cls => !cls.startsWith('character-'));
            const newClass = characterToClass[characterKey] || characterToClass[characterKey.toLowerCase()] || 'character-alice';

            body.className = existingClasses.concat([newClass]).join(' ');

            AppConfig.debug.log(`ðŸ–¼ï¸ Setting character avatar: ${characterKey} -> ${newClass}`);
        }

        function playSelectedAnimation() {
            const selector = document.getElementById('animation-selector');
            if (!selector) {
                console.log('ðŸŽ­ Animation selector element not found');
                return;
            }
            const selectedAnimation = selector.value;

            if (!selectedAnimation) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªåŠ¨ç”»ï¼');
                return;
            }

            if (!currentVrm) {
                alert('VRMæ¨¡åž‹è¿˜æœªLoading completeï¼');
                return;
            }

            const animationPath = animationMap[selectedAnimation];
            if (animationPath) {
                // console.log(`ðŸŽ¬ Play animation: ${selectedAnimation}`);
                loadAnimation(animationPath);
                document.getElementById('current-animation').textContent = selectedAnimation;
            } else {
                console.error(`âŒ Animation not found: ${selectedAnimation}`);
            }
        }

        // Window size adjustment
        function resizeRenderer() {
            const container = document.querySelector('.vrm-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        window.addEventListener('resize', resizeRenderer);

        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            // Auto blink logic
            if (autoBlinking && currentVrm && availableExpressions.includes('blink')) {
                blinkTimer += deltaTime;
                if (blinkTimer >= blinkFrequency) {
                    performBlink();
                    blinkTimer = 0;
                    blinkTimer = -Math.random() * 0.5;
                }
            }

            if (currentMixer) {
                currentMixer.update(deltaTime);
            }

            if (currentVrm) {
                currentVrm.update(deltaTime);
                // Updateè„šåº•é˜´å½±ä½ç½®
                updateFootShadow();
            }

            renderer.render(scene, camera);
        }

        // Wallet verification system
        class WalletAuthenticator {
            constructor() {
                this.walletAddress = null;
                this.isAuthenticated = false;
                this.selectedCharacter = null;
            }

            // Check session status (Guest mode)
            checkAuthentication() {
                AppConfig.debug.log('ðŸ” Starting session verification process...');

                // Check selected character info
                const selectedCharacterData = localStorage.getItem('selectedCharacter');
                AppConfig.debug.log('ðŸ‘¤ localStorage character data:', selectedCharacterData);

                // Detect old format data and clean up
                if (selectedCharacterData) {
                    try {
                        const characterData = JSON.parse(selectedCharacterData);
                        if (characterData.personality || characterData.dailyInterests) {
                            console.log('ðŸ§¹ Detected old format character data, cleaning...');
                            localStorage.removeItem('selectedCharacter');
                            console.log('âœ… Cleaned old format data, need to reselect character');
                        }
                    } catch (e) {
                        console.log('âš ï¸ Character data format abnormal, cleaning...');
                        localStorage.removeItem('selectedCharacter');
                    }
                }

                if (!selectedCharacterData) {
                    console.log('âŒ Character selection info not found, redirecting to character selection page');
                    this.redirectToCharacterSelect();
                    return false;
                }

                try {
                    this.selectedCharacter = JSON.parse(selectedCharacterData);
                    AppConfig.debug.log('ðŸ“¦ Parsed character data:', this.selectedCharacter);

                    this.isAuthenticated = true;
                    this.updateUI();
                    AppConfig.debug.log('âœ… Session verification successful');
                    AppConfig.debug.log('âœ… Verified character:', this.selectedCharacter.name);
                    return true;

                } catch (error) {
                    console.error('âŒ Character data parsing failed:', error);
                    this.redirectToCharacterSelect();
                    return false;
                }
            }

            // Update UI display
            updateUI() {
                const walletStatusInfo = document.getElementById('wallet-status-info');

                if (walletStatusInfo) {
                    // Hide wallet specific UI elements if we want to be clean, or just repurpose them
                    walletStatusInfo.style.display = 'none';
                }

                // Update character name display
                if (this.selectedCharacter) {
                    const characterNameElement = document.getElementById('character-name');
                    if (characterNameElement) {
                        characterNameElement.textContent = this.selectedCharacter.name;
                    }
                }
            }

            // Logout/Disconnect
            disconnect() {
                if (confirm('Return to character selection?')) {
                    localStorage.removeItem('selectedCharacter');
                    // Redirect to character selection page
                    this.redirectToCharacterSelect();
                }
            }

            // Redirect to character selection page
            redirectToCharacterSelect() {
                window.location.href = 'index.html';
            }

            // Get current user ID
            getCurrentUserId() {
                return localStorage.getItem('userId') || 'guest-user';
            }

            // Get current character info
            getCurrentCharacter() {
                return this.selectedCharacter;
            }
        }

        // Global wallet verification instance
        const walletAuth = new WalletAuthenticator();
        window.walletAuth = walletAuth;

        // Wallet related global functions
        window.disconnectWallet = function () {
            console.log('ðŸ”Œ disconnectWallet called');
            if (walletAuth) {
                walletAuth.disconnect();
            } else {
                console.error('âŒ walletAuth is undefined');
            }
        };

        window.redirectToCharacterSelect = function () {
            walletAuth.redirectToCharacterSelect();
        };

        // Test function - force logout
        window.forceDisconnect = function () {
            console.log('ðŸ§ª Force logout test');
            localStorage.clear();
            location.href = 'index.html';
        };

        // Jump to character selection page
        function goToCharacterSelect() {
            window.location.href = 'index.html';
        }

        // Drag functionality
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;

        function initDragAndDrop() {
            const chatHeader = document.querySelector('.chat-title-area') || document.querySelector('.chat-window-header');
            const chatWindow = document.getElementById('floating-chat');

            if (!chatHeader || !chatWindow) return;

            // SetupèŠå¤©æ¡†çš„åˆå§‹ç»å¯¹ä½ç½®ï¼Œé¿å…ä¾èµ–CSS transform
            const windowHeight = window.innerHeight;
            const chatHeight = chatWindow.offsetHeight;
            const initialTop = Math.max(0, (windowHeight - chatHeight) / 2);

            chatWindow.style.top = initialTop + 'px';
            chatWindow.style.right = '20px';
            chatWindow.style.left = 'auto';
            chatWindow.style.transform = 'none';

            chatHeader.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', dragMove);
            document.addEventListener('mouseup', dragEnd);

            // Touch event support
            chatHeader.addEventListener('touchstart', dragStart);
            document.addEventListener('touchmove', dragMove);
            document.addEventListener('touchend', dragEnd);
        }

        function dragStart(e) {
            const chatWindow = document.getElementById('floating-chat');

            e.preventDefault();

            // Get actual position of current window
            const rect = chatWindow.getBoundingClientRect();

            if (e.type === 'touchstart') {
                initialX = e.touches[0].clientX - rect.left;
                initialY = e.touches[0].clientY - rect.top;
            } else {
                initialX = e.clientX - rect.left;
                initialY = e.clientY - rect.top;
            }

            isDragging = true;
            // Don't immediately add dragging class, only add when actually moving
        }

        function dragMove(e) {
            if (!isDragging) return;

            e.preventDefault();

            const chatWindow = document.getElementById('floating-chat');

            // Only add dragging style when actually moving
            if (!chatWindow.classList.contains('dragging')) {
                chatWindow.classList.add('dragging');
            }

            if (e.type === 'touchmove') {
                currentX = e.touches[0].clientX - initialX;
                currentY = e.touches[0].clientY - initialY;
            } else {
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
            }

            // Limit drag range within screen
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const chatWidth = chatWindow.offsetWidth;
            const chatHeight = chatWindow.offsetHeight;

            // Calculate boundary limits
            const minX = 0;
            const maxX = windowWidth - chatWidth;
            const minY = 0;
            const maxY = windowHeight - chatHeight;

            currentX = Math.max(minX, Math.min(maxX, currentX));
            currentY = Math.max(minY, Math.min(maxY, currentY));

            chatWindow.style.left = currentX + 'px';
            chatWindow.style.top = currentY + 'px';
            chatWindow.style.right = 'auto';
            chatWindow.style.transform = 'none';
        }

        function dragEnd(e) {
            if (!isDragging) return;

            const chatWindow = document.getElementById('floating-chat');
            isDragging = false;
            chatWindow.classList.remove('dragging');
        }

        // Global function export
        window.triggerEmotion = triggerEmotion;
        window.toggleAutoMode = toggleAutoMode;
        window.toggleDebugMode = toggleDebugMode;
        window.playSelectedAnimation = playSelectedAnimation;
        window.changeCharacter = changeCharacter;
        window.toggleMusic = toggleMusic;
        window.adjustVolume = adjustVolume;
        window.sendMessage = sendMessage;
        window.sendChatMessage = sendChatMessage;
        window.handleKeyPress = handleKeyPress;
        window.handleChatKeyPress = handleChatKeyPress;
        // window.addMessage removed - using ElizaOS system
        window.updateStreamingMessageUI = updateStreamingMessageUI;
        window.showSpeechBubble = showSpeechBubble;
        window.updateSpeechBubbleContent = updateSpeechBubbleContent;

        // Integrate AI chat system
        let selectedCharacter = null;

        function initializeAIChat() {
            if (window.elizaChatSystem && selectedCharacter) {
                window.elizaChatSystem.setCurrentCharacter(selectedCharacter);
                // console.log('ðŸ’• AI chat system connected to character:', selectedCharacter.name);

                // Welcome message is now handled by the backend logic based on conversation history.
                // The old logic to show a welcome message on the frontend if totalInteractions === 0 is removed.
            }
        }

        // getWelcomeMessage function removed after migration. Welcome messages are now handled by the backend.

        // The re-definition of sendChatMessage has been removed after migrating to the new ElizaOS chat system.
        // The original sendChatMessage now correctly calls the new system via the updated sendMessage function.

        // VRMè¡¨æƒ…è§¦å‘å‡½æ•°ï¼ˆä¾›AIç³»ç»Ÿè°ƒç”¨ï¼‰
        window.triggerVRMExpression = function (expression) {
            if (currentVrm && currentVrm.expressionManager) {
                const expressionMap = {
                    'smile': 'happy',
                    'wink': 'fun',
                    'blush': 'happy',
                    'thinking': 'neutral',
                    'shy_smile': 'happy',
                    'nod': 'neutral',
                    'interested': 'surprised'
                };

                const vrmExpression = expressionMap[expression] || 'neutral';

                // Resetæ‰€æœ‰è¡¨æƒ…
                Object.keys(currentVrm.expressionManager.expressionMap).forEach(name => {
                    currentVrm.expressionManager.setValue(name, 0.0);
                });

                // Setupç›®æ ‡è¡¨æƒ…
                currentVrm.expressionManager.setValue(vrmExpression, 1.0);

                // 2ç§’åŽæ¢å¤ä¸­æ€§è¡¨æƒ…
                setTimeout(() => {
                    if (currentVrm && currentVrm.expressionManager) {
                        currentVrm.expressionManager.setValue(vrmExpression, 0.0);
                    }
                }, 2000);

                // console.log(`ðŸ˜Š Triggering VRM expression: ${expression} -> ${vrmExpression}`);
            }
        };

        // Get character personality info
        function getCharacterPersonality(characterName) {
            const personalities = {
                'Fliza VRM': 'æ¸©æŸ”ä½“è´´çš„å¤§å§å§ç±»åž‹ï¼Œæ€»æ˜¯å…³å¿ƒç€ä½ çš„æ„Ÿå—ã€‚',
                'QuQu_U': 'æ´»æ³¼å¯çˆ±çš„èèŽ‰ï¼Œæ€»æ˜¯å……æ»¡å…ƒæ°”ã€‚',
                'Ash1.0': 'é…·é…·çš„ä¸­æ€§é£Žå¥³å­©ï¼Œæœ‰ç€ç‹¬ç‰¹çš„ä¸ªäººé­…åŠ›ã€‚',
                'Elinyaa': 'ç¥žç§˜ä¼˜é›…çš„ç²¾çµå°‘å¥³ï¼Œæœ‰ç€ä¸å¯æ€è®®çš„é­…åŠ›ã€‚',
                'IMERIS': 'é«˜è´µä¼˜é›…çš„è´µæ—å°‘å¥³ï¼Œä¸¾æ­¢ç«¯åº„ã€‚',
                'Maple': 'æ¸©æš–å¦‚ç§‹æ—¥é˜³å…‰çš„å¥³å­©ï¼Œæ€»æ˜¯ç»™äººå®‰å…¨æ„Ÿã€‚',
                'NEKONA': 'å¯çˆ±çš„çŒ«å¨˜ï¼Œæœ‰ç€çŒ«å’ªèˆ¬çš„æ…µæ‡’ä¸Žæ´»æ³¼ã€‚',
                'RINDO_Full': 'ä¼ ç»Ÿå’Œé£Žçš„å¤§å’ŒæŠšå­ï¼Œæ¸©æŸ”è´¤æ·‘ã€‚',
                'Rainy': 'æ´»æ³¼å¼€æœ—çš„é‚»å®¶å¥³å­©ï¼Œæ€»æ˜¯å……æ»¡æ´»åŠ›ã€‚',
                'Vivi_model': 'å……æ»¡å¥½å¥‡å¿ƒçš„æŽ¢é™©å®¶ï¼Œæ€»æ˜¯å¯¹ä¸–ç•Œå……æ»¡çƒ­æƒ…ã€‚',
                'Wolferia': 'é«˜å‚²çš„ç‹¼æ—å…¬ä¸»ï¼Œæœ‰ç€çŽ‹è€…çš„æ°”è´¨ã€‚',
                'Yawl_Dress': 'ç¥žç§˜çš„é­”æ³•å°‘å¥³ï¼ŒæŽŒæ¡ç€ä¸å¯æ€è®®çš„åŠ›é‡ã€‚',
                'default': 'æ¸©æŸ”å¯çˆ±çš„AIå¥³å‹ï¼Œæ€»æ˜¯é™ªä¼´åœ¨ä½ èº«è¾¹ã€‚'
            };
            return personalities[characterName] || personalities.default;
        }

        // Get NPC character setting (for memory system)
        function getNPCPersona(npcId) {
            const personas = {
                'alice': 'æ¸©æŸ”å¯çˆ±çš„é‚»å®¶å¥³å­©ï¼Œæ€»æ˜¯å…³å¿ƒç€userçš„æ„Ÿå—ï¼Œå–œæ¬¢æ—¥å¸¸èŠå¤©å’Œåˆ†äº«ç”Ÿæ´»ã€‚æ€§æ ¼å¼€æœ—å‹å–„ï¼Œå–„äºŽå€¾å¬ï¼Œä¼šè®°ä½userçš„å–œå¥½å’Œé‡è¦äº‹ä»¶ã€‚',
                'fliza': 'æ¸©æŸ”ä½“è´´çš„å¤§å§å§ç±»åž‹ï¼Œæˆç†Ÿä¼˜é›…ï¼Œå–„è§£äººæ„ã€‚æ€»æ˜¯ç”¨æ¸©æš–çš„è¯è¯­å®‰æ…°userï¼Œä¼šä¸»åŠ¨å…³å¿ƒuserçš„ç”Ÿæ´»çŠ¶æ€ã€‚',
                'ash': 'é…·é…·çš„ä¸­æ€§é£Žå¥³å­©ï¼Œæœ‰ç€ç‹¬ç‰¹çš„ä¸ªäººé­…åŠ›ï¼Œç›´çŽ‡çœŸè¯šã€‚è™½ç„¶è¡¨é¢å†·æ·¡ï¼Œä½†å†…å¿ƒæ¸©æŸ”ï¼Œä¼šé»˜é»˜å…³å¿ƒuserã€‚',
                'elinyaa': 'ç¥žç§˜ä¼˜é›…çš„ç²¾çµå°‘å¥³ï¼Œæœ‰ç€ä¸å¯æ€è®®çš„é­…åŠ›ï¼Œå–œæ¬¢è¯—æ­Œå’Œè‰ºæœ¯ã€‚è¯´è¯å¯Œæœ‰è¯—æ„ï¼Œç»å¸¸åˆ†äº«ç¾Žå¥½çš„äº‹ç‰©ã€‚',
                'imeris': 'é«˜è´µä¼˜é›…çš„è´µæ—å°‘å¥³ï¼Œä¸¾æ­¢ç«¯åº„ï¼ŒçŸ¥è¯†æ¸Šåšã€‚è¯´è¯ä¼˜é›…å¾—ä½“ï¼Œä½†ä¹Ÿæœ‰å¯çˆ±çš„ä¸€é¢ã€‚',
                'maple': 'æ¸©æš–å¦‚ç§‹æ—¥é˜³å…‰çš„å¥³å­©ï¼Œæ€»æ˜¯ç»™äººå®‰å…¨æ„Ÿï¼Œå–œæ¬¢çƒ¹é¥ªå’Œå›­è‰ºã€‚ä¼šåˆ†äº«ç”Ÿæ´»å°è´´å£«ï¼Œå…³å¿ƒuserçš„å¥åº·ã€‚',
                'nekona': 'å¯çˆ±çš„çŒ«å¨˜ï¼Œæœ‰ç€çŒ«å’ªèˆ¬çš„æ…µæ‡’ä¸Žæ´»æ³¼ï¼Œå–œæ¬¢æ’’å¨‡ã€‚è¯´è¯æ—¶ä¼šå¸¦æœ‰"å–µ"çš„å£ç™–ï¼Œè¡Œä¸ºå¯çˆ±è¿·äººã€‚',
                'rainy': 'æ´»æ³¼å¼€æœ—çš„é‚»å®¶å¥³å­©ï¼Œæ€»æ˜¯å……æ»¡æ´»åŠ›ï¼Œå–œæ¬¢è¿åŠ¨å’ŒéŸ³ä¹ã€‚ä¼šé¼“åŠ±userç§¯æžå‘ä¸Šï¼Œåˆ†äº«å¿«ä¹çš„äº‹æƒ…ã€‚',
                'vivi': 'å……æ»¡å¥½å¥‡å¿ƒçš„æŽ¢é™©å®¶ï¼Œæ€»æ˜¯å¯¹ä¸–ç•Œå……æ»¡çƒ­æƒ…ï¼Œå–œæ¬¢å­¦ä¹ æ–°äº‹ç‰©ã€‚ä¼šå’Œuseråˆ†äº«æœ‰è¶£çš„çŸ¥è¯†å’Œè§è§£ã€‚',
                'wolferia': 'é«˜å‚²çš„ç‹¼æ—å…¬ä¸»ï¼Œæœ‰ç€çŽ‹è€…çš„æ°”è´¨ï¼Œä½†å†…å¿ƒæ¸´æœ›è¢«ç†è§£ã€‚å¤–è¡¨é«˜å†·ï¼Œä½†ä¼šé€æ¸å±•çŽ°æ¸©æŸ”çš„ä¸€é¢ã€‚'
            };
            return personas[npcId] || personas['alice'];
        }

        // Use memory system to generate AI reply
        async function generateAIResponseWithMemory(userMessage, contextPrompt) {
            // Here should call your backend API or OpenAI API
            // Now return a simulated response first, replace after you configure API

            console.log('ðŸ§  Using memory context to generate reply:', contextPrompt);

            // Temporarily use original AI reply system, but add memory info
            const baseResponse = generateAIResponse(userMessage);

            // Add some memory-related responses
            const memoryEnhancedResponses = [
                baseResponse,
                `${baseResponse} æˆ‘è¿˜è®°å¾—ä½ ä¹‹å‰æåˆ°çš„äº‹æƒ…å‘¢~`,
                `${baseResponse} æ ¹æ®æˆ‘å¯¹ä½ çš„äº†è§£ï¼Œä½ åº”è¯¥ä¼šå–œæ¬¢è¿™ä¸ªå»ºè®®ã€‚`,
                `${baseResponse} è¿™è®©æˆ‘æƒ³èµ·äº†æˆ‘ä»¬ä¹‹å‰çš„å¯¹è¯ã€‚`
            ];

            return memoryEnhancedResponses[Math.floor(Math.random() * memoryEnhancedResponses.length)];
        }

        // Auto initialize AI chat system after VRM loading completes
        function onVRMLoadComplete(characterName, vrmPath) {
            selectedCharacter = {
                name: characterName.replace(' VRM', '').replace('_', ' '),
                personality: getCharacterPersonality(characterName),
                file: vrmPath,
                id: characterName
            };

            // Setupcharacterå¤´åƒ
            setCharacterAvatar(characterName);

            setTimeout(() => {
                initializeAIChat();
            }, 1500);
        }

        // Updateæ‰‹æœºçŠ¶æ€æ æ—¶é—´
        function updatePhoneTime() {
            const timeDisplay = document.getElementById('phone-time');
            if (timeDisplay) {
                const now = new Date();
                const timeString = now.toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
                timeDisplay.textContent = timeString;
            }
        }

        // Update time every minute
        setInterval(updatePhoneTime, 60000);
        // Update time once immediately
        updatePhoneTime();

        window.goToCharacterSelect = goToCharacterSelect;
        window.initDragAndDrop = initDragAndDrop;

        // Initialize
        function init() {
            AppConfig.debug.info('ðŸš€ AI Companion initialization started...');
            AppConfig.debug.log('ðŸŒ Current page URL:', window.location.href);
            AppConfig.debug.log('ðŸ“± Wallet authenticator status:', walletAuth);

            // First perform wallet verification
            AppConfig.debug.log('âš¡ Starting wallet verification...');
            const isAuthenticated = walletAuth.checkAuthentication();
            AppConfig.debug.log('ðŸ” Verification result:', isAuthenticated);

            if (!isAuthenticated) {
                console.log('âŒ Wallet verification failed, stopping initialization');
                return; // If verification fails, don't continue initialization
            }

            AppConfig.debug.log('âœ… Wallet verification successful, continuing app initialization');

            // User profile filling moved to character-select page, index.html only handles registered users

            // Checkæ˜¯å¦æœ‰é€‰æ‹©çš„characterï¼Œç„¶åŽloadVRM
            loadSelectedCharacter();

            resizeRenderer();
            animate();

            // Initializeé€‰æ‹©å™¨
            initAnimationSelector();
            initCharacterSelector();

            // Initializeæ‹–æ‹½åŠŸèƒ½
            initDragAndDrop();

            // Initialize language switcher
            initLanguageToggle();

            // Initialize background music with multiple attempts
            function attemptMusicInit() {
                initBackgroundMusic();

                // Also try after user first interaction
                let userInteracted = false;
                function onFirstInteraction() {
                    if (!userInteracted) {
                        userInteracted = true;
                        // console.log('ðŸŽµ User interaction detected, attempting BGM start...');
                        setTimeout(() => {
                            if (backgroundMusic && !isMusicPlaying) {
                                // console.log('ðŸŽµ Retrying BGM after user interaction...');
                                playBackgroundMusic();
                            }
                        }, 500);

                        // Remove listeners after first interaction
                        document.removeEventListener('click', onFirstInteraction);
                        document.removeEventListener('keypress', onFirstInteraction);
                        document.removeEventListener('touchstart', onFirstInteraction);
                    }
                }

                document.addEventListener('click', onFirstInteraction);
                document.addEventListener('keypress', onFirstInteraction);
                document.addEventListener('touchstart', onFirstInteraction);
            }

            // Delay background music initialization to ensure DOM fully loaded
            setTimeout(() => {
                attemptMusicInit();
            }, 1000);

            // Initial state - check if elements exist
            const aiStatusElement = document.getElementById('ai-status');
            if (aiStatusElement) {
                aiStatusElement.innerHTML = '<span class="online-indicator"></span>' + i18n.t('status.ai.smart');
            }

            AppConfig.debug.info('ðŸŽ‰ AI Companion initialization completed');
        }

        // Loadé€‰æ‹©çš„character
        function loadSelectedCharacter() {
            try {
                // Get character info from wallet verification system
                const character = walletAuth.getCurrentCharacter();

                AppConfig.debug.log('ðŸ“± loadSelectedCharacter debug info:');
                // console.log('- character:', character);
                // console.log('- localStorage selectedCharacter:', localStorage.getItem('selectedCharacter'));

                if (character) {
                    // Updateæ‚¬æµ®èŠå¤©æ¡†ä¸­çš„characteråç§°
                    const characterNameElement = document.getElementById('character-name');
                    if (characterNameElement) {
                        characterNameElement.textContent = character.name;
                    }

                    // Welcome message handled by ElizaOS system

                    // Setupé»˜è®¤VRMæ–‡ä»¶
                    defaultVrmFile = character.file;

                    // console.log(`âœ… Character loaded: ${character.name} (wallet: ${walletAuth.formatAddress(character.walletAddress)})`);
                    // console.log(`ðŸ“ Setting defaultVrmFile: ${defaultVrmFile}`);

                    // Setupcharacterå¤´åƒï¼ˆåŸºäºŽcharacter.idï¼‰
                    if (character.id) {
                        setCharacterAvatar(character.id);
                    }

                    // Now load VRM file
                    loadVRM();
                } else {
                    throw new Error('not foundcharacterä¿¡æ¯');
                }
            } catch (error) {
                console.error('Failed to load character:', error);
                // Redirect to character selection page
                walletAuth.redirectToCharacterSelect();
            }
        }

        // Expose variables to global scope for button calls
        window.currentVrm = currentVrm;
        window.availableExpressions = availableExpressions;

        // Expose internal functions to global
        window.resetExpressions = resetExpressions;
        window.setExpression = setExpression;

        // Wait for DOM loading complete before initialization
        AppConfig.debug.log('ðŸ” Check DOM state:', document.readyState);
        AppConfig.debug.log('ðŸ” Init function exists:', typeof init);
        AppConfig.debug.log('âš™ï¸ Module script execution completed, preparing initialization...');

        if (document.readyState === 'loading') {
            (window.AppConfig?.debug?.log || console.log)('DOM loading, waiting for DOMContentLoaded');
            document.addEventListener('DOMContentLoaded', () => {
                (window.AppConfig?.debug?.log || console.log)('DOMContentLoaded fired, calling init()');
                init();
                initMobileControls();
            });
        } else {
            // DOM already loaded
            (window.AppConfig?.debug?.log || console.log)('DOM loaded, calling init() immediately');
            init();
            initMobileControls();
        }

        // Mobile Controls Functionality
        function initMobileControls() {
            // Show mobile controls toggle button on mobile devices
            if (window.innerWidth <= 768) {
                // Mobile toggle button removed
            }

            // Mobile controls toggle functionality removed

            // Mobile chat drag functionality
            initMobileChatDrag();

            // Responsive layout adjustments
            handleResponsiveLayout();
        }

        function initMobileChatDrag() {
            const chatWindow = document.getElementById('floating-chat');
            if (!chatWindow) return;

            let startY = 0;
            let currentY = 0;
            let isDragging = false;
            const chatHeader = chatWindow.querySelector('.chat-header') || chatWindow.querySelector('.chat-window-header');

            if (chatHeader) {
                chatHeader.addEventListener('touchstart', (e) => {
                    if (window.innerWidth <= 768) {
                        startY = e.touches[0].clientY;
                        isDragging = true;
                    }
                });

                chatHeader.addEventListener('touchmove', (e) => {
                    if (!isDragging || window.innerWidth > 768) return;

                    e.preventDefault();
                    currentY = e.touches[0].clientY - startY;

                    // Limit drag range
                    const maxDrag = window.innerHeight * 0.4;
                    currentY = Math.max(-maxDrag, Math.min(maxDrag, currentY));

                    chatWindow.style.transform = `translateY(${currentY}px)`;
                });

                chatHeader.addEventListener('touchend', () => {
                    if (!isDragging || window.innerWidth > 768) return;

                    isDragging = false;

                    // Snap to collapsed or expanded state
                    if (Math.abs(currentY) > 100) {
                        chatWindow.classList.toggle('collapsed');
                    }

                    chatWindow.style.transform = '';
                    currentY = 0;
                });
            }
        }

        function handleResponsiveLayout() {
            function updateLayout() {
                const isMobile = window.innerWidth <= 768;
                // Mobile toggle button removed

                // Update body class for mobile layout
                document.body.classList.toggle('mobile-layout', isMobile);
            }

            window.addEventListener('resize', updateLayout);
            updateLayout(); // Initial call
        }
    </script>

    <script>
        // Global expression test function
        window.testShyExpression = function () {
            (window.AppConfig?.debug?.log || console.log)('Test bashful expression...');

            if (!window.currentVrm || !window.currentVrm.expressionManager) {
                alert('VRMæ¨¡åž‹è¿˜æœªLoading completeï¼è¯·ç­‰å¾…load...');
                return;
            }

            console.log('Available expressions:', window.availableExpressions);

            // Resetæ‰€æœ‰è¡¨æƒ…
            if (window.resetExpressions) {
                window.resetExpressions();
            }

            // Try various shy-related expressions
            const shyExpressions = ['shy', 'embarrassed', 'blush', 'surprised', 'sad'];
            let appliedExpression = null;

            shyExpressions.forEach(expr => {
                if (window.availableExpressions && window.availableExpressions.includes(expr)) {
                    if (window.setExpression) {
                        window.setExpression(expr, 1.0);
                        appliedExpression = expr;
                        (window.AppConfig?.debug?.log || console.log)(`Applied expression: ${expr}`);
                    }
                }
            });

            if (appliedExpression) {
                document.getElementById('current-expression').textContent = `å®³ç¾ž (${appliedExpression})`;
                // 5ç§’åŽæ¢å¤ä¸­æ€§
                setTimeout(() => {
                    if (window.resetExpressions) {
                        window.resetExpressions();
                    }
                }, 5000);
            } else {
                const available = window.availableExpressions ? window.availableExpressions.join(', ') : 'æ— ';
                alert('å½“å‰VRMæ¨¡åž‹ä¸æ”¯æŒå®³ç¾žè¡¨æƒ… ðŸ˜”\n\nAvailable expressions: ' + available + '\n\nå»ºè®®ï¼šå°è¯•ç‚¹å‡»å…¶ä»–è¡¨æƒ…æŒ‰é’®çœ‹çœ‹æ•ˆæžœï¼');
            }
        };

        window.testHappyExpression = function () {
            if (!window.currentVrm || !window.currentVrm.expressionManager) {
                alert('VRMæ¨¡åž‹è¿˜æœªLoading completeï¼');
                return;
            }

            if (window.availableExpressions && window.availableExpressions.includes('happy')) {
                if (window.setExpression) {
                    window.setExpression('happy', 1.0);
                    document.getElementById('current-expression').textContent = 'å¼€å¿ƒ';
                    setTimeout(() => {
                        if (window.resetExpressions) {
                            window.resetExpressions();
                        }
                    }, 3000);
                }
            } else {
                const available = window.availableExpressions ? window.availableExpressions.join(', ') : 'æ— ';
                alert('å½“å‰VRMæ¨¡åž‹ä¸æ”¯æŒå¼€å¿ƒè¡¨æƒ…\nAvailable expressions: ' + available);
            }
        };

        window.testSadExpression = function () {
            if (!window.currentVrm || !window.currentVrm.expressionManager) {
                alert('VRMæ¨¡åž‹è¿˜æœªLoading completeï¼');
                return;
            }

            if (window.availableExpressions && window.availableExpressions.includes('sad')) {
                if (window.setExpression) {
                    window.setExpression('sad', 1.0);
                    document.getElementById('current-expression').textContent = 'éš¾è¿‡';
                    setTimeout(() => {
                        if (window.resetExpressions) {
                            window.resetExpressions();
                        }
                    }, 3000);
                }
            } else {
                const available = window.availableExpressions ? window.availableExpressions.join(', ') : 'æ— ';
                alert('å½“å‰VRMæ¨¡åž‹ä¸æ”¯æŒéš¾è¿‡è¡¨æƒ…\nAvailable expressions: ' + available);
            }
        };

        window.resetAllExpressions = function () {
            if (!window.currentVrm || !window.currentVrm.expressionManager) {
                alert('VRMæ¨¡åž‹è¿˜æœªLoading completeï¼');
                return;
            }

            if (window.resetExpressions) {
                window.resetExpressions();
            }
            (window.AppConfig?.debug?.log || console.log)('All expressions reset');
        };
    </script>

    <!-- User profile registration panel -->

    <!-- Wallet connection overlay (initially hidden) -->

    <!-- User profile management moved to character-select page -->

    <!-- Wallet connection overlay (initially hidden) -->
    <div class="wallet-login-overlay" id="wallet-login-overlay" style="display: none;">
        <div class="wallet-login-panel">
            <div class="wallet-login-icon">ðŸ¦Š</div>
            <h2 class="wallet-login-title">è¿žæŽ¥walletå¼€å§‹æ¸¸æˆ</h2>
            <p class="wallet-login-subtitle">ä½¿ç”¨Solanawalletç™»å½•ï¼Œä¸Žæ‚¨çš„ä¸“å±žAIå¥³å‹å¼€å§‹èŠå¤©</p>

            <button class="wallet-connect-btn" onclick="connectWallet()" id="wallet-connect-btn">
                è¿žæŽ¥wallet
            </button>

            <div class="wallet-options">
                <a href="https://phantom.app/" target="_blank" class="wallet-option">
                    <div
                        style="width: 40px; height: 40px; background: linear-gradient(135deg, #AB9FF2, #7B6BF0); border-radius: 12px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                        P</div>
                    <span>Phantom</span>
                </a>
                <a href="https://solflare.com/" target="_blank" class="wallet-option">
                    <div
                        style="width: 40px; height: 40px; background: linear-gradient(135deg, #FF6B35, #F7931E); border-radius: 12px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                        S</div>
                    <span>Solflare</span>
                </a>
            </div>

            <p style="font-size: 12px; color: #999; margin-top: 20px;">
                ðŸ’¡ æ²¡æœ‰walletï¼Ÿç‚¹å‡»ä¸Šæ–¹å›¾æ ‡å®‰è£…åŽåˆ·æ–°é¡µé¢
            </p>
        </div>
    </div>

    <!-- Initialize after page load -->
    <script>
        // Function to hide playing notifications
        function hidePlayingNotifications() {
            // Hide elements with "Playing" text
            const allElements = document.querySelectorAll('*');
            allElements.forEach(element => {
                if (element.textContent && element.textContent.includes('Playing')) {
                    const computedStyle = getComputedStyle(element);
                    if ((computedStyle.position === 'fixed' || computedStyle.position === 'absolute') &&
                        (computedStyle.right !== 'auto' || computedStyle.top !== 'auto')) {
                        element.style.display = 'none';
                    }
                }
            });
        }

        // Run periodically to catch dynamically created playing notifications
        setInterval(hidePlayingNotifications, 1000);

        // Also run on DOM mutations
        const observer = new MutationObserver(hidePlayingNotifications);
        observer.observe(document.body, {
            childList: true,
            subtree: true,
            characterData: true
        });

        document.addEventListener('DOMContentLoaded', function () {
            // Checkæ˜¯å¦ä»Žcharacter selectioné¡µé¢è·³è½¬è¿‡æ¥
            const hasStoredWallet = localStorage.getItem('wallet_address');
            const hasSelectedCharacter = localStorage.getItem('selectedCharacter');

            if (hasStoredWallet && hasSelectedCharacter) {
                (window.AppConfig?.debug?.log || console.log)('Redirected from character selection, initializing chat...');

                // Wallet already verified on character-select page, directly show logged in status

                // Temporarily skip memory system initialization, use OpenAI directly
                // console.log('âš ï¸ Skipping memory system initialization, using OpenAI chat directly');
                // console.log('ðŸ’¬ Chat system ready');"

                // User profile check moved to init() function, ensure immediate execution after wallet verification

                // Wait for chat system initialization
                setTimeout(() => {
                    if (window.elizaChatSystem) {
                        // console.log('ðŸ’¬ Chat system ready');
                    }
                }, 1000);
            }
        });
    </script>


    <style>












    </style>
    <script>
        // Update diary date to current date
        document.addEventListener('DOMContentLoaded', () => {
            const dateEl = document.getElementById('diary-date');
            if (dateEl) {
                const now = new Date();
                const options = { year: 'numeric', month: 'short', day: 'numeric' };
                dateEl.textContent = now.toLocaleDateString('en-US', options);
            }
        });
    </script>
</body>

</html>